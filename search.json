[{"title":"北航co计算机组成P3设计文档","url":"/2026/02/13/P3co/","content":"写在前面：本人在 P3 时尚未认识到看学长学姐博客的重要性，于是整个人根据课上老师讲解和指导书要求乱七八糟的搭建了一个CPU，毫无美观可言接口设计的超级不好，在这里就不展示了。P4 的时候看了一些博客设计了一个比较美观的CPU，（P4 只是把logisim上的CPU用verilog实现）所以接口设计可以参考 P4 ，指路链接在下面。\n\n\n          \n            \n              \n              \n                北航co计算机组成P4设计文档\n                可以看看！！\n              \n            \n          \n\nP3 CPU设计文档及思考题设计草稿1.指令详解\nADD：add RD, RS, RT编码：000000 sssss ttttt ddddd 00000 100000描述：GPR[rd] &#x3D; GPR[rs] + GPR[rt]\nSUB：sub RD, RS, RT 编码：000000 sssss ttttt ddddd 00000 100010  描述：GPR[rd] &#x3D; GPR[rs] - GPR[rt]\nORI：ori RT, RS, IMM  编码：001101 sssss ttttt iiiii iiiii iiiiii描述：GPR[rt] &#x3D; GPR[rs] | zero_extend(IMM)\nLW：lw RT, OFFSET(RS)  编码：100011 sssss ttttt iiiii iiiii iiiiii描述：GPR[rt] &#x3D; MEM[GPR[rs] + sign_ext(OFFSET)]\nSW：sw RT, OFFSET(RS)  编码：101011 sssss ttttt iiiii iiiii iiiiii描述：MEM[GPR[rs] + sign_ext(OFFSET)] &#x3D; GPR[rt]\nBEQ：beq RS, RT, LABEL  编码：000100 sssss ttttt iiiii iiiii iiiiii描述：if GPR[rs] &#x3D;&#x3D; GPR[rt], PC &#x3D; PC + 4 + sign_ext(LABEL);  else PC &#x3D; PC + 4;\nlui：lui RT, IMM  编码：001111 00000 ttttt iiiii iiiii iiiiii描述：GPR[rt] &#x3D; sign_ext(IMM) &lt;&lt; 16;\nnop：nop  编码：000000 00000 00000 00000 00000 000000描述：GPR[0] &#x3D; GPR[0]\n\n2.数据通路设计\n\n\n操作\nAdder-A1\nAdder-A2\nshifter1\nPC\nIM\nsplitter\nGRF-RA1\nGRF-RA2\nGRF-WA\nGRT-WD\nALU-A1\nALU-A2\nDM-RA\nDM-WA\nDM-WD\nEXT\nshifter2\n\n\n\nadd\nPC\n4\n-\nadder\npc\nim\nsplitter[s]\nsplitter[t]\nsplitter[d]\nALU\nGRF-RD1\nGRF-RD2\n-\n-\n-\n-\n-\n\n\nsub\nPC\n4\n-\nadder\npc\nim\nsplitter[s]\nsplitter[t]\nsplitter[d]\nALU\nGRF-RD1\nGRF-RD2\n-\n-\n-\n-\n-\n\n\nori\nPC\n4\n-\nadder\npc\nim\nsplitter[s]\n-\nsplitter[t]\nALU\nGRF-RD1\nEXT\n-\n-\n-\nsplitter[i]\n-\n\n\nlw\nPC\n4\n-\nadder\npc\nim\nsplitter[s]\n-\nsplitter[t]\nDM-RD\nGRF-RD1\nEXT\nALU\n-\n-\nsplitter[i]\n-\n\n\nsw\nPC\n4\n-\nadder\npc\nim\nsplitter[s]\nsplitter[t]\n-\n-\nGRF-RD1\nEXT\n-\nALU\nGRF-RD2\nsplitter[i]\n-\n\n\nbeq\nPC\n4&#x2F;4+shifter1\nEXT&lt;&lt;2\nadder\npc\nim\nsplitter[s]\nsplitter[t]\n-\n-\nGRF-RD1\nGRF-RD2\n-\n-\n-\nsplitter[i]\n-\n\n\nlui\nPC\n4\n-\nadder\npc\nim\n-\nsplitter[t]\nshifter2\n-\n-\n-\n-\n-\n-\nsplitter[i]\nEXT&lt;&lt;16\n\n\n&#x2F;&#x2F;IFU由Adder、shifter、PC、IM构成\n3.控制信号总控制\n\n\n数值\nRegWA_control\nRegWD_control\nRegWrite\nALU_Inputcontrol_2\nMemWrite\nEXTcontrol\n\n\n\n0\nsplitter[t]\nALU\nunable\nGRF-RD2\nunable\nzero_extend\n\n\n1\nsplitter[d]\nDM\nenable\nEXT\nenable\nsign_extend\n\n\n2(10)\n-\nshifter2\n-\n-\n-\n-\n\n\nALU控制000 : +001 : -010 : |\n\n\n\n指令\nALU操作\nALUcontrol\n\n\n\nadd\n+\n000\n\n\nsub\n-\n001\n\n\nori\nor\n010\n\n\nlw\n+\n000\n\n\nsw\n+\n000\n\n\nbeq\n&#x3D;&#x3D;\n-\n\n\nlui\n-\n-\n\n\n课上：本人没有记录课上题目，不过P3会有推荐题，在时间宽裕的情况下可以做。\n我知道一些同学会喜欢增加很多指导书没有涉及的指令，有利有弊，利在可以对添加指令更加熟练。弊在你的CPU会越来越复杂，而且课上添加的指令肯定是mips指令集中没有出现过的，如果课上添加指令的编码op恰好和自行添加的指令op一致，这将给课上造成很大的麻烦。\n课上可以有取巧的方法：（歪门邪道了\n\n直接新建模块对新增指令进行运算，模块的input为所需运算的值，output是结果\n将新建模块连接入mips顶层中，连接输入输出\n使用多路选择器输出结果，即如果op和新增指令一样（判断可以加在control中），结果即用新增模块的结果，其他的按照原本课下不变\n\n思考题点击展开，不保证正确性，建议自己思考思考题1.上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。状态存储功能：PC、GRF、DM状态转移功能：ALU、EXT、Controller\n2.现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出合理。IM使用ROM是合理的，因为指令在运行时通常是不改变的，ROM是只读的，符合指令存储的需求。DM使用RAM是合理的，因为数据需要读写，RAM可以读写，符合数据存储的需求。GRF使用Register是合理的，因为寄存器堆需要快速读写，且每个时钟周期都要更新，使用寄存器可以实现。\n3.在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。增加了shifter以实现lui所需要的位移（但可能可以加入在ALU中）\n4.事实上，实现 nop 空指令，我们并不需要将它加入控制信号真值表，为什么？nop指令在MIPS中实际上是 sll $0, $0, 0。其高6位为000000会在控制信号中被识别为R类指令，其任何操作都是对0号寄存器操作，$0寄存器无论如何都为0，相当于没有进行任何操作。所以不需要在控制信号真值表中对nop进行单独讨论。\n5.阅读 Pre 的 “MIPS 指令集及汇编语言” 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。ori 指令：覆盖行为：从0号寄存器加载立即数。从非零寄存器进行或操作。立即数为正数。不足之处：未测试立即数为边界值（如 0x0000 或 0xffff）。未测试源寄存器为其他非零值时的复杂逻辑组合。\nlui 指令覆盖行为：加载正立即数。加载负立即数。不足之处：未测试立即数为 0x0000 的情况。未测试与后续 ori 组合形成完整32位值的所有情况（如正负组合）。\nadd 指令覆盖行为：正数加正数。正数加负数。负数加负数。不足之处：未测试加法溢出情况。未测试零加零或零加其他数的情况。未测试结果为零的情况。\nsw和lw指令覆盖行为：存储和加载到内存的不同偏移地址。存储后重新加载并再次存储。不足之处：未测试内存访问的地址边界情况。\nbeq 指令覆盖行为：分支不发生。分支发生。","categories":["计算机","co"],"tags":["北航","大二","co"]},{"title":"北航co计算机组成P5设计文档","url":"/2026/02/13/P5co/","content":"写在前面：本人 P5 课上其实有bug，也没有写好一些扩展性很好的接口，还有一些比较奇怪的设计，比如 lui 指令偷了一个周期，GRF也没有设计内部转发，流水线寄存器传递的也太多太乱，所以本人在 P6 几乎进行了一整个重构P6 设计文档指路链接在下面。（一周写 P5 确实很不合理，如果时间紧张写不完不妨主动gap一周。）\n\n\n          \n            \n              \n              \n                北航co计算机组成P6设计文档\n                可以看看！！\n              \n            \n          \n\nP5CPU设计文档及思考题设计草稿1.指令详解\nADD：add RD, RS, RT编码：000000 sssss ttttt ddddd 00000 100000描述：GPR[rd] &#x3D; GPR[rs] + GPR[rt]\nSUB：sub RD, RS, RT编码：000000 sssss ttttt ddddd 00000 100010描述：GPR[rd] &#x3D; GPR[rs] - GPR[rt]\nORI：ori RT, RS, IMM编码：001101 sssss ttttt iiiii iiiii iiiiii描述：GPR[rt] &#x3D; GPR[rs] | zero_extend(IMM)\nLW：lw RT, OFFSET(RS)编码：100011 sssss ttttt iiiii iiiii iiiiii描述：GPR[rt] &#x3D; MEM[GPR[rs] + sign_ext(OFFSET)]\nSW：sw RT, OFFSET(RS)编码：101011 sssss ttttt iiiii iiiii iiiiii描述：MEM[GPR[rs] + sign_ext(OFFSET)] &#x3D; GPR[rt]\nBEQ：beq RS, RT, LABEL编码：000100 sssss ttttt iiiii iiiii iiiiii描述：if GPR[rs] &#x3D;&#x3D; GPR[rt], PC &#x3D; PC + 4 + sign_ext(LABEL);  else PC &#x3D; PC + 4;\nlui：lui RT, IMM编码：001111 00000 ttttt iiiii iiiii iiiiii描述：GPR[rt] &#x3D; sign_ext(IMM) &lt;&lt; 16;\njal: jal target编码：000011 iiiii iiiii iiiii iiiii iiiiii描述：GPR[31] &#x3D; PC + 4;  PC &#x3D; PC[31,28]||instr_index||00\njr: jr rs编码：000000 sssss 00000 00000 00000 001000描述：PC &#x3D; GPR[rs]\nnop：nop编码：000000 00000 00000 00000 00000 000000描述：GPR[0] &#x3D; GPR[0]\n\n2.各部件接口设计NPC\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nPC\nI\n31:0\n前一拍指令地址\n\n\noffset\nI\n31:0\n用于计算B类指令跳转地址\n\n\nIns_26\nI\n25:0\n用于计算J、JAL跳转地址\n\n\nRa\nI\n31:0\n用于读取JR、JALR中寄存器存储的地址\n\n\nB_judge\nI\n1\n用于判断B类指令是否满足跳转条件\n\n\nif_Branch\nI\n1\n用于判断是否为B类指令\n\n\nif_JR\nI\n1\n用于判断是否为J、JR指令\n\n\nNext_PC\nO\n31:0\n下一拍指令地址\n\n\nPC+4\nO\n31:0\n上一拍指令地址+4，用于JAL、JALR地址存储\n\n\n注意跳转指令PC要是它本身的PC，即beq指令的PC要和上一个周期的一样,不和延迟槽一样，不用+4.\nIFU\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nclk\nI\n1\n时钟信号\n\n\nReset\nI\n1\n同步复位信号\n\n\nNext_PC\nI\n31:0\n计算出的下一拍指令地址\n\n\nEn\nI\n1\n有效信号，阻塞时为0\n\n\nPC\nO\n31:0\n当前指令地址\n\n\nInstr\nO\n31:0\n当前指令内容\n\n\nGRF\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nPC\nI\n31:0\n当前指令地址\n\n\nRA1\nI\n4:0\n读寄存器1地址\n\n\nRA2\nI\n4:0\n读寄存器2地址\n\n\nWA\nI\n4:0\n写寄存器地址\n\n\nWD\nI\n31:0\n写寄存器数据\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n同步复位信号\n\n\nRegWrite\nI\n1\n写寄存器控制信号\n\n\nRD1\nO\n31:0\n读寄存器1数据\n\n\nRD2\nO\n31:0\n读寄存器2数据\n\n\nALU\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nALU_Op\nI\n3:0\nALU操作码\n\n\nSrc_A\nI\n31:0\nALU输入A数据\n\n\nSrc_B\nI\n31:0\nALU输入B数据\n\n\nshift\nI\n5:0\n位移量（对B数据进行位移）\n\n\nALU_Result\nO\n31:0\nALU输出结果\n\n\nDM\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nclk\nI\n1\n时钟信号\n\n\nReset\nI\n1\n同步复位信号\n\n\nPC\nI\n31:0\n当前指令地址\n\n\nMemWrite\nI\n1\n写内存控制信号\n\n\nA\nI\n31:0\n写地址\n\n\nWD\nI\n31:0\n写数据\n\n\nRD\nO\n31:0\n读数据\n\n\nEXT\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nImm\nI\n15:0\n扩展前的立即数\n\n\nif_sign\nI\n1\n是否为有符号扩展\n\n\noffset\nO\n31:0\n扩展后的立即数\n\n\nCMP\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nD1\nI\n31:0\n数据1\n\n\nD2\nI\n31:0\n数据2\n\n\nCMPOP\nI\n2:0\n比较操作码\n\n\nout\nO\n1\n比较结果\n\n\nlui\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nImm\nI\n15:0\n扩展后的立即数\n\n\nlui_reset\nO\n31:0\n计算结果\n\n\n3.数据通路设计NPC\n\n\n操作\nPC\noffset\nIns_26\nRA\nif_Branch\nif_jr\nif_jal\n\n\n\nall\nIFU\nEXT\nsplitter\nGRF\ncontrol\ncontrol\ncontrol\n\n\nIFU\n\n\n操作\nclk\nReset\nNext_PC\n\n\n\nall\nclk\nreset\nNPC\n\n\nGRF\n\n\n操作\nclk\nReset\nRA1\nRA2\nWA\nWD\nRegWrite\n\n\n\nadd\nclk\nreset\nsplitter[s]\nsplitter[t]\nsplitter[d]\nALU\ncontrol\n\n\nsub\nclk\nreset\nsplitter[s]\nsplitter[t]\nsplitter[d]\nALU\ncontrol\n\n\nori\nclk\nreset\nsplitter[s]\n-\nsplitter[t]\nALU\ncontrol\n\n\nlw\nclk\nreset\nsplitter[s]\n-\nsplitter[t]\nDM\ncontrol\n\n\nsw\nclk\nreset\nsplitter[s]\nsplitter[t]\n-\n-\ncontrol\n\n\nbeq\nclk\nreset\nsplitter[s]\nsplitter[t]\n-\n-\ncontrol\n\n\nlui\nclk\nreset\n-\n-\nsplitter[t]\nALU\ncontrol\n\n\njal\nclk\nreset\n-\n-\n31\nNPC\ncontrol\n\n\njr\nclk\nreset\nsplitter[s]\n-\n-\n-\ncontrol\n\n\nALU\n\n\n操作\nALU_Op\nSrc_A\nSrc_B\nshift\n\n\n\nadd\ncontrol\nGRF-RD1\nGRF-RD2\n-\n\n\nsub\ncontrol\nGRF-RD1\nGRF-RD2\n-\n\n\nori\ncontrol\nGRF-RD1\nEXT\n-\n\n\nlw\ncontrol\nGRF-RD1\nEXT\n-\n\n\nsw\ncontrol\nGRF-RD1\nEXT\n-\n\n\nbeq\ncontrol\nGRF-RD1\nGRF-RD2\n-\n\n\nlui\ncontrol\n-\nEXT\n16\n\n\njal\n-\n-\n-\n-\n\n\njr\n-\n-\n-\n-\n\n\nDM\n\n\n操作\nclk\nReset\nMemWrite\nA\nWD\n\n\n\nlw\nclk\nreset\ncontrol\nALU-Result\n-\n\n\nsw\nclk\nreset\ncontrol\nALU-Result\nGRF-RD2\n\n\nelse\n-\n-\n-\n-\n-\n\n\nEXT\n\n\n操作\nImm\nif_sign\n\n\n\nall\nsplitter[i]\ncontrol\n\n\n4.流水线寄存器F&#x2F;D\n\n\n名称\n位宽\n描述\n\n\n\nclk\n1\n时钟信号\n\n\nreset\n1\n同步复位信号\n\n\nen\n1\n有效信号，阻塞时为0\n\n\n-\n-\n-\n\n\nPC\n31:0\n指令地址\n\n\nInstr\n31:0\n指令内容\n\n\nPC+8\n31:0\nJal存的内容\n\n\nD&#x2F;E\n\n\n名称\n位宽\n描述\n\n\n\nclk\n1\n时钟信号\n\n\nreset\n1\n同步复位信号\n\n\nclr\n1\n清空信号，阻塞时为0\n\n\n-\n-\n-\n\n\nPC\n31:0\n指令地址\n\n\nop\n5:0\n指令操作码\n\n\nRfunct\n5:0\nR指令功能码\n\n\nuseReg\n1\n是否使用寄存器\n\n\nWA\n4:0\n写寄存器地址\n\n\nWD\n31:0\n写寄存器数据\n\n\nRegWrite\n1\n写寄存器控制信号\n\n\nTnew\n1\nTnew &#x3D; (Tnew &gt; 0)? Tnew - 1 : Tnew\n\n\n-\n-\n-\n\n\nRD1\n31:0\n读寄存器1数据\n\n\nRD2\n31:0\n读寄存器2数据\n\n\nrs\n4:0\n读寄存器1地址\n\n\nrt\n4:0\n读寄存器2地址\n\n\noffset\n31:0\n扩展后的立即数\n\n\nshift\n5:0\n位移量（对B数据进行位移）\n\n\nE&#x2F;M\n\n\n名称\n位宽\n描述\n\n\n\nclk\n1\n时钟信号\n\n\nreset\n1\n同步复位信号\n\n\n-\n-\n-\n\n\nPC\n31:0\n指令地址\n\n\nop\n5:0\n指令操作码\n\n\nRfunct\n5:0\nR指令功能码\n\n\nuseReg\n1\n是否使用寄存器\n\n\nWA\n4:0\n写寄存器地址\n\n\nWD\n31:0\n写寄存器数据\n\n\nRegWrite\n1\n写寄存器控制信号\n\n\nTnew\n1\nTnew &#x3D; (Tnew &gt; 0)? Tnew - 1 : Tnew\n\n\n-\n-\n-\n\n\nRD2\n31:0\n读寄存器2数据\n\n\nALU_Result\n31:0\nALU输出结果\n\n\nM&#x2F;W\n\n\n名称\n位宽\n描述\n\n\n\nclk\n1\n时钟信号\n\n\nreset\n1\n同步复位信号\n\n\n-\n-\n-\n\n\nPC\n31:0\n指令地址\n\n\nWA\n4:0\n写寄存器地址\n\n\nWD\n31:0\n写寄存器数据\n\n\nRegWrite\n1\n写寄存器控制信号\n\n\nTnew\n1\nTnew &#x3D; (Tnew &gt; 0)? Tnew - 1 : Tnew\n\n\n5.控制信号总控制\n\n\n数值\nMemToReg\nMemWrite\nALUSrc\nRegWrite\nsignedEXT\nRegDst\nif_Branch\nif_JR\nif_JAL\nALUToReg\nRalink\nluitoReg\n\n\n\n控制的位置\nGRF-WD\nDM-MemWrite\nALU-SrcB\nGRF-RegWrite\nEXT-if_sign\nGRF-WA\nNPC-if_Branch\nNPC-if_JR\nNPC-if_JAL\nGRF-WD\nGRF-WA\nALU_shift\n\n\n0\nALU\nunable\nGRF-RD2\nunable\nzero_extend\nsplitter[t]\nNOT-BEQ\nNOT-JR\nNOT-JAL\nWD不是ALU结果\n-\nlui_result是WD需要的\n\n\n1\nDM\nenable\nEXT\nenable\nsign_extend\nsplitter[d]\nBEQ\nJR\nJAL\nWD不是ALU结果\n将PC+4存入寄存器的编号（31）(WA的分支)\nlui_result是WD需要的\n\n\nALU控制0000 : +0001 : -0010 : |0011 : 数据B向左位移shift位\ncmp控制000: &#x3D;&#x3D;\n指令对应控制信号\n\n\n指令\nALU操作\ncmp控制\nALUcontrol\nMemToReg\nMemWrite\nALUSrc\nRegWrite\nsignedEXT\nRegDst\nif_Branch\nif_JR\nif_JAL\nALUToReg\nRalink\nluiToreg\n\n\n\nadd\n+\n0000\n000\n0\n0\n0\n1\n-\n1\n0\n0\n0\n1\n0\n0\n\n\nsub\n-\n0001\n000\n0\n0\n0\n1\n-\n1\n0\n0\n0\n1\n0\n0\n\n\nori\nor\n0010\n000\n0\n0\n1\n1\n0\n0\n0\n0\n0\n1\n0\n0\n\n\nlw\n+\n0000\n000\n1\n0\n1\n1\n1\n0\n0\n0\n0\n0\n0\n0\n\n\nsw\n+\n0000\n000\n-\n1\n1\n0\n1\n0\n0\n0\n0\n0\n0\n0\n\n\nbeq\n&#x3D;&#x3D;\n-\n000\n0\n0\n0\n0\n1\n-\n1\n0\n0\n0\n0\n0\n\n\nlui\n&lt;&lt;\n0011\n000\n0\n0\n1\n1\n-\n0\n0\n0\n0\n0\n0\n1\n\n\njal\n-\n-\n000\n0\n0\n-\n1\n-\n0\n0\n0\n1\n0\n1\n0\n\n\njr\n-\n-\n000\n0\n0\n-\n0\n-\n-\n0\n1\n0\n0\n0\n0\n\n\nD控制RegWrite,signedEXT,RegDst,if_Branch,if_JR,if_JAL,luiToReg,Ralink,cmp_op\nE控制ALUSrc,ALUToReg,ALU_Op\nM控制MemToReg,MemWrite\n阻塞转发Tuse 和 Tnew 的分析Tuse表示数据到了 D 级之后还需要多少个周期要使用，每个指令的是固定不变的。Tnew表示数据还有多长时间产生，会随着数据的流水动态的减少。（但是大于1）Tuse表格\n\n\n\n指令\nrs_Tuse\nrt_Tuse\n\n\n\nR(除了jr)\n1\n1\n\n\nori\n1\n-\n\n\nlw\n1\n-\n\n\nsw\n1\n2\n\n\nbeq\n0\n0\n\n\nJR\n0\n-\n\n\n其他的都是if_use&#x3D;0\n\n\n\n\nD级时Tnew表格\n\n\n\n指令\nTnew\n\n\n\nR(除了jr)\n2\n\n\nori\n2\n\n\nlw\n3\n\n\nlui\n1\n\n\njal\n0\n\n\n其他的都是RegWrite&#x3D;0\n\n\n\n阻塞转发的判断当Tuse≥Tnew时，可以通过转发解决；当Tuse &lt; Tnew时，必须阻塞流水线。\n阻塞操作：冻结PC寄存器（IFU_en &#x3D; ~stall &#x3D; 0）冻结D级寄存器（D_en &#x3D; ~stall &#x3D; 0）清空E级寄存器（E_clr &#x3D; stall &#x3D; 1）\n转发操作：转发需要：\n\nGRF内部转发\nD需要E、M的转发\nE需要M、W的转发\nM需要W的转发\n\n课上保证课下正确很重要！可以写评测机，或者使用伟大的cot评测机！！\n\n          \n            \n              \n              \n                cot评测机\n                伟大的评测机！！\n              \n            \n          \n\nP5以及P6的题目类型都比较固定，可以提前写好一些接口，比如control可以增加判断新指令的接口，流水线寄存器也可以增加传递的接口，接口可以命名为new之类的，方便课上使用。\n以下是课上题目的一些分析：\n1. 计算类型形如：\nWriteData &lt;- f(GPR[rs], GPR[rt])GPR[rd] &lt;- WriteData\n做法：\n\n在控制模块中识别新指令，设置控制信号\n新增 ALU 计算类型\n新增各流水线级转发数据\n\n仿照 add 指令编写\n2. 条件跳转类型形如：\ncondition &lt;- f(GPR[rs], Ext_Ans)if condition:\tjump \t(GPR[rt] &lt;- data)else:\t(NullifyDelayedBranch)\t\n\n控制模块中设置控制信号\n计算 condition\n跳转仿照 beq\n条件写入用特判+凌驾的做法，记得改 D-E 级流水线寄存器的输入\n清空延迟槽，新增控制信号Clr_F，Clr_F为真的条件：condition为假 &amp;&amp; D级是新指令 &amp;&amp; 此时不能阻塞\n\n3. 访存类型形如：\nDMdata &lt;- DM[addr]data &lt;- f(DMdata, GPR[rt])dest_reg &lt;- f(data)GPR[dest_reg] &lt;- data\n\ndata、dest_reg 是在 W级 算出来的，M-W 流水线传 rt\nW级该指令转发 data\ndest_reg 最好在 没算出来之前都是 0，防止转发冲突\ndest_reg 的范围很重要\n比较阻塞的时候，依次比较E，M级，条件为：是新指令 &amp;&amp; 要写寄存器 &amp;&amp; 寄存器处在 dest_reg 范围内 &amp;&amp; RA！&#x3D;0 &amp;&amp; Tuse &lt; Tnew\n\n往年题依旧指路室友博客\n\n          \n            \n              \n              \n                室友博客\n                室友博客详细往年题记载！\n              \n            \n          \n\n\n\n思考题点击展开，不保证正确性，建议自己思考思考题1、我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。提前判断意味着需要更早从寄存器堆读取数据，如果数据还未写回（比如上一条指令的 ALU 结果在 EX 阶段才产生），就需要转发或停顿。如果分支判断依赖于上一条指令的结果（比如 LW 后跟 BEQ 使用刚加载的值），即使提前到 ID 阶段判断，仍然需要等待数据就绪，否则必须停顿。\n2、因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？jal指令在IF阶段取指，下一条指令（延迟槽指令）在IF的同时，jal进入ID阶段。因为延迟槽指令一定会执行，所以 jal 应该返回到延迟槽之后的指令，即 PC+8，这样才能跳过延迟槽，正确返回。\n3、我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？如果直接从功能部件转发，可能因为组合逻辑路径过长导致时钟周期过长，导致性能下降。\n4、我们为什么要使用 GPR 内部转发？该如何实现？目的：解决写数据冒险。当一条指令在WB阶段写寄存器，同时下一条指令在ID阶段读同一个寄存器，如果不处理，会读到旧值。实现：在寄存器堆的写端口与读端口之间添加内部转发逻辑。比较 WB 阶段要写入的寄存器地址与 ID 阶段要读取的寄存器地址。如果地址相同且写使能有效，则将 WB 阶段要写入的数据直接作为读出的数据送给 ID 阶段，而不等待真正写入寄存器堆。这样 ID 阶段能立即拿到刚计算出的结果，避免 1 个周期的停顿。\n5、我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？数据需求者：ID 阶段、EX 阶段、MEM 阶段数据供给者：MEM 阶段、WB 阶段，还有GPR内部转发。转发数据通路：MEM 阶段&#x2F;WB 阶段&#x2F;GPR内部转发 -&gt; ID 阶段MEM 阶段&#x2F;WB 阶段 -&gt; EX 阶段WB 阶段 -&gt; MEM 阶段\n6、在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。1. 计算类型形如：\nWriteData &lt;- f(GPR[rs], GPR[rt])GPR[rd] &lt;- WriteData\n做法：\n\n在控制模块中识别新指令，设置控制信号\n新增 ALU 计算类型\n新增各流水线级转发数据\n\n仿照 add 指令编写\n2. 条件跳转类型形如：\ncondition &lt;- f(GPR[rs], Ext_Ans)if condition:\tjump \t(GPR[rt] &lt;- data)else:\t(NullifyDelayedBranch)\t\n\n控制模块中设置控制信号\n计算 condition\n跳转仿照 beq\n条件写入用特判+凌驾的做法，记得改 D-E 级流水线寄存器的输入\n清空延迟槽，新增控制信号Clr_F，Clr_F为真的条件：condition为假 &amp;&amp; D级是新指令 &amp;&amp; 此时不能阻塞\n\n3. 访存类型形如：\nDMdata &lt;- DM[addr]data &lt;- f(DMdata, GPR[rt])dest_reg &lt;- f(data)GPR[dest_reg] &lt;- data\n\ndata、dest_reg 是在 W级 算出来的，M-W 流水线传 rt\nW级该指令转发 data\ndest_reg 最好在 没算出来之前都是 0，防止转发冲突\ndest_reg 的范围很重要\n比较阻塞的时候，依次比较E，M级，条件为：是新指令 &amp;&amp; 要写寄存器 &amp;&amp; 寄存器处在 dest_reg 范围内 &amp;&amp; RA！&#x3D;0 &amp;&amp; Tuse &lt; Tnew\n\n7、确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。译码方式：罗列控制信号每种取值所对应指令。译码器结构：分布式译码：每一级都部署一个控制器，负责译出当前级所需控制信号。另外判断阻塞的信号单独生成。优势：分布式译码较为灵活，有效降低了流水级间传递的信号量。方便明白这一级中完成了哪些内容不足：需要实例化多个控制器，增加了后续流水级的逻辑复杂度。同时，增加指令需要增加修改多个控制器。","categories":["计算机","co"],"tags":["北航","大二","co"]},{"title":"北航co计算机组成P6设计文档","url":"/2026/02/13/P6co/","content":"P6CPU设计文档及思考题设计草稿1.指令详解(1)calc_R:\nADD：add RD, RS, RT 编码：000000 sssss ttttt ddddd 00000 100000 描述：GPR[rd] &#x3D; GPR[rs] + GPR[rt]\nSUB：sub RD, RS, RT 编码：000000 sssss ttttt ddddd 00000 100010 描述：GPR[rd] &#x3D; GPR[rs] - GPR[rt\nAND：and RD, RS, RT 编码：000000 sssss ttttt ddddd 00000 100100 描述：GPR[rd] &#x3D; GPR[rs] &amp; GPR[rt]\nOR：or RD, RS, RT 编码：000000 sssss ttttt ddddd 00000 100101 描述：GPR[rd] &#x3D; GPR[rs] | GPR[rt]\nSLT：slt RD, RS, RT 编码：000000 sssss ttttt ddddd 00000 101010 描述：if GPR[rs] &lt; GPR[rt], GPR[rd] &#x3D; 1; else GPR[rd] &#x3D; 0;是有符号的比较\nSLTU：sltu RD, RS, RT 编码：000000 sssss ttttt ddddd 00000 101011 描述：if GPR[rs] &lt; GPR[rt], GPR[rd] &#x3D; 1; else GPR[rd] &#x3D; 0; 但是是无符号的比较\n\n(2)calc_I:\nADDI：addi RT, RS, IMM 编码：001000 sssss ttttt iiiii iiiii iiiiii 描述：GPR[rt] &#x3D; GPR[rs] + sign_ext(IMM)\nANDI：andi RT, RS, IMM 编码：001100 sssss ttttt iiiii iiiii iiiiii 描述：GPR[rt] &#x3D; GPR[rs] &amp; zero_extend(IMM)\nORI：ori RT, RS, IMM 编码：001101 sssss ttttt iiiii iiiii iiiiii 描述：GPR[rt] &#x3D; GPR[rs] | zero_extend(IMM)\n\n(3)load:\nLB：lb RT, OFFSET(RS) 编码：100000 sssss ttttt iiiii iiiii iiiiii 描述：GPR[rt] &#x3D; sign_ext(MEM[GPR[rs] + sign_ext(OFFSET)][7:0]) 操作：\n\nAddr = GPR[base] + sign_ext(offset) memword = memory[Addr] byte = Addr1..0 GPR[rt] = sign_ext(memword7+8*byte..8*byte) \n\nLH：lh RT, OFFSET(RS) 编码：100001 sssss ttttt iiiii iiiii iiiiii 描述：GPR[rt] &#x3D; sign_ext(MEM[GPR[rs] + sign_ext(OFFSET)][15:0]) 操作：\n\nAddr = GPR[base] + sign_ext(offset) memword = memory[Addr] byte = Addr1 GPR[rt] = sign_ext(memword15+16*byte..16*byte) \n\n\nLW：lw RT, OFFSET(RS) 编码：100011 sssss ttttt iiiii iiiii iiiiii 描述：GPR[rt] &#x3D; MEM[GPR[rs] + sign_ext(OFFSET)]\n\n(4)store:\nSB：sb RT, OFFSET(RS) 编码：101000 sssss ttttt iiiii iiiii iiiiii 描述：MEM[GPR[rs] + sign_ext(OFFSET)] &#x3D; GPR[rt][7:0] 操作：\n\nAddr = GPR[base] + sign_extend(offset) byte = Addr1..0 memory[Addr]7+8*byte..8*byte = GPR[rt]7:0 \n\nSH：sh RT, OFFSET(RS) 编码：101001 sssss ttttt iiiii iiiii iiiiii 描述：MEM[GPR[rs] + sign_ext(OFFSET)] &#x3D; GPR[rt][15:0] 操作：\n\nAddr = GPR[base] + sign_extend(offset) byte = Addr1 memory[Addr]15+16*byte..16*byte = GPR[rt]15:0 \n\nSW：sw RT, OFFSET(RS) 编码：101011 sssss ttttt iiiii iiiii iiiiii 描述：MEM[GPR[rs] + sign_ext(OFFSET)] &#x3D; GPR[rt]\n\n（5）md:\nmult：mult rs, rt编码：000000 sssss ttttt 00000 00000 011000描述：HI, LO &#x3D; GPR[rs] * GPR [rt](有符号)\nmultu：multu rs, rt编码：000000 sssss ttttt 00000 00000 011001描述：HI, LO &#x3D; GPR[rs] * GPR[rt]\ndiv：div rs, rt编码：000000 sssss ttttt 00000 00000 011010描述：LO &#x3D; GPR[rs]&#x2F; GPR[rt];  HI &#x3D; GPR[rs] % GPR[rt]（有符号）\ndivu：divu rs, rt编码：000000 sssss ttttt 00000 00000 011011描述：LO &#x3D; GPR[rs] &#x2F; GPR[rt];  HI &#x3D; GPR[rs] % GPR[rt]\n\n（6）mf:\nmflo：mflo rd 编码：000000 00000 00000 ddddd 00000 010010 描述：GPR[rd] &#x3D; LO\nmfhi：mfhi rd 编码：000000 00000 00000 ddddd 00000 010000 描述：GPR[rd] &#x3D; HI\n\n(7)mt:\nmtlo：mtlo rs 编码：000000 sssss 00000 00000 00000 010011 描述：LO &#x3D; GPR[rs]\nmthi：mthi rs 编码：000000 sssss 00000 00000 00000 010001 描述：HI &#x3D; GPR[rs]\n\n(8)B:\nBEQ：beq RS, RT, LABEL 编码：000100 sssss ttttt iiiii iiiii iiiiii 描述：if GPR[rs] &#x3D;&#x3D; GPR[rt], PC &#x3D; PC + 4 + sign_ext(LABEL);  else PC &#x3D; PC + 4;\nBNE：bne RS, RT, LABEL 编码：000101 sssss ttttt iiiii iiiii iiiiii 描述：if GPR[rs] !&#x3D; GPR[rt], PC &#x3D; PC + 4 + sign_ext(LABEL);  else PC &#x3D; PC + 4;\n\n（9）Other:\nlui：lui RT, IMM 编码：001111 00000 ttttt iiiii iiiii iiiiii 描述：GPR[rt] &#x3D; sign_ext(IMM) &lt;&lt; 16;\njal: jal target 编码：000011 iiiii iiiii iiiii iiiii iiiiii 描述：GPR[31] &#x3D; PC + 4;  PC &#x3D; PC[31,28]||instr_index||00\njr: jr rs 编码：000000 sssss 00000 00000 00000 001000 描述：PC &#x3D; GPR[rs]\nnop：nop 编码：000000 00000 00000 00000 00000 000000 描述：GPR[0] &#x3D; GPR[0]\n\n2.各部件接口设计NPC\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nPC\nI\n31:0\n前一拍指令地址\n\n\noffset\nI\n31:0\n用于计算B类指令跳转地址\n\n\nIns_26\nI\n25:0\n用于计算J、JAL跳转地址\n\n\nRa\nI\n31:0\n用于读取JR、JALR中寄存器存储的地址\n\n\nB_judge\nI\n1\n用于判断B类指令是否满足跳转条件\n\n\nif_Branch\nI\n1\n用于判断是否为B类指令\n\n\nif_JR\nI\n1\n用于判断是否为J、JR指令\n\n\nNext_PC\nO\n31:0\n下一拍指令地址\n\n\nPC+4\nO\n31:0\n上一拍指令地址+4，用于JAL、JALR地址存储\n\n\n注意跳转指令PC要是它本身的PC，即beq指令的PC要和上一个周期的一样,不和延迟槽一样，不用+4.\nIFU\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nclk\nI\n1\n时钟信号\n\n\nReset\nI\n1\n同步复位信号\n\n\nNext_PC\nI\n31:0\n计算出的下一拍指令地址\n\n\nEn\nI\n1\n有效信号，阻塞时为0\n\n\nPC\nO\n31:0\n当前指令地址\n\n\nGRF\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nPC\nI\n31:0\n当前指令地址\n\n\nRA1\nI\n4:0\n读寄存器1地址\n\n\nRA2\nI\n4:0\n读寄存器2地址\n\n\nWA\nI\n4:0\n写寄存器地址\n\n\nWD\nI\n31:0\n写寄存器数据\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n同步复位信号\n\n\nRegWrite\nI\n1\n写寄存器控制信号\n\n\nRD1\nO\n31:0\n读寄存器1数据\n\n\nRD2\nO\n31:0\n读寄存器2数据\n\n\nALU\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nALU_Op\nI\n3:0\nALU操作码\n\n\nSrc_A\nI\n31:0\nALU输入A数据\n\n\nSrc_B\nI\n31:0\nALU输入B数据\n\n\nshift\nI\n5:0\n位移量（对B数据进行位移）\n\n\nALU_Result\nO\n31:0\nALU输出结果\n\n\nEXT\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nImm\nI\n15:0\n扩展前的立即数\n\n\nif_sign\nI\n1\n是否为有符号扩展\n\n\noffset\nO\n31:0\n扩展后的立即数\n\n\nCMP\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nD1\nI\n31:0\n数据1\n\n\nD2\nI\n31:0\n数据2\n\n\nCMPOP\nI\n2:0\n比较操作码\n\n\nout\nO\n1\n比较结果\n\n\nMDU\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n同步复位信号\n\n\nstart\nI\n1\n乘除法开始运算信号\n\n\nMDU_Op\nI\n3:0\nMDU操作码\n\n\nA\nI\n31:0\n操作数A\n\n\nB\nI\n31:0\n操作数B\n\n\nHI\nO\n31:0\n乘除法结果\n\n\nLO\nO\n31:0\n乘除法结果\n\n\nout\nO\n31:0\n运算结果\n\n\nbusy\nO\n1\n乘除法运算忙信号\n\n\nBE\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nA\nI\n1:0\nDM写入地址的低2位\n\n\nLSOp\nI\n2:0\n访存功能信号\n\n\nWD_in\nI\n31:0\n未经处理的DM写入数据\n\n\nbyteen\nO\n3:0\nDM字节使能信号\n\n\nWD_out\nO\n31:0\n经过处理的DM写入数据\n\n\nDE\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nA\nI\n2\n\n\n\nRD_in\nI\n32\n未经处理的DM读出数据\n\n\nLSOp\nI\n2\n访存功能信号\n\n\nRD_out\nO\n32\n处理后的DM读出数据\n\n\n3.数据通路设计NPC\n\n\n操作\nPC\noffset\nIns_26\nRA\nif_Branch\nif_jr\nif_jal\n\n\n\nall\nIFU\nEXT\nsplitter\nGRF\ncontrol\ncontrol\ncontrol\n\n\nIFU\n\n\n操作\nclk\nReset\nNext_PC\n\n\n\nall\nclk\nreset\nNPC\n\n\nGRF\n\n\n操作\nclk\nReset\nRA1\nRA2\nWA\nWD\nRegWrite\n\n\n\nadd\nclk\nreset\nsplitter[s]\nsplitter[t]\nsplitter[d]\nALU\ncontrol\n\n\nsub\nclk\nreset\nsplitter[s]\nsplitter[t]\nsplitter[d]\nALU\ncontrol\n\n\nori\nclk\nreset\nsplitter[s]\n-\nsplitter[t]\nALU\ncontrol\n\n\nlw\nclk\nreset\nsplitter[s]\n-\nsplitter[t]\nDM\ncontrol\n\n\nsw\nclk\nreset\nsplitter[s]\nsplitter[t]\n-\n-\ncontrol\n\n\nbeq\nclk\nreset\nsplitter[s]\nsplitter[t]\n-\n-\ncontrol\n\n\nlui\nclk\nreset\n-\n-\nsplitter[t]\nALU\ncontrol\n\n\njal\nclk\nreset\n-\n-\n31\nNPC\ncontrol\n\n\njr\nclk\nreset\nsplitter[s]\n-\n-\n-\ncontrol\n\n\nALU\n\n\n操作\nALU_Op\nSrc_A\nSrc_B\nshift\n\n\n\nadd\ncontrol\nGRF-RD1\nGRF-RD2\n-\n\n\nsub\ncontrol\nGRF-RD1\nGRF-RD2\n-\n\n\nori\ncontrol\nGRF-RD1\nEXT\n-\n\n\nlw\ncontrol\nGRF-RD1\nEXT\n-\n\n\nsw\ncontrol\nGRF-RD1\nEXT\n-\n\n\nbeq\ncontrol\nGRF-RD1\nGRF-RD2\n-\n\n\nlui\ncontrol\n-\nEXT\n16\n\n\njal\n-\n-\n-\n-\n\n\njr\n-\n-\n-\n-\n\n\nEXT\n\n\n操作\nImm\nif_sign\n\n\n\nall\nsplitter[i]\ncontrol\n\n\n4.流水线寄存器\n\n\n名称\n功能\nF_D\nD_E\nE_M\nM_W\n\n\n\nIR\n指令\n√\n√\n√\n√\n\n\nPC\n指令地址\n√\n√\n√\n√\n\n\nWD\n写寄存器数据\n-\n√\n√\n√\n\n\nWA\n写寄存器地址\n-\n√\n√\n√\n\n\nRegWrite\n写寄存器控制信号\n-\n√\n√\n√\n\n\nTnew\n数据产生时间\n-\n√\n√\n√\n\n\n其他\n\nPC+8\nRD1,RD2,offset\nRD2,ALU_Result\n-\n\n\n5.控制信号总控制\n\n\n数值\nMemToReg\nMemWrite\nALUSrc\nRegWrite\nsignedEXT\nRegDst\nif_Branch\nif_JR\nif_JAL\nALUToReg\nRalink\nlui\n\n\n\n控制的位置\nGRF-WD\nDM-MemWrite\nALU-SrcB\nGRF-RegWrite\nEXT-if_sign\nGRF-WA\nNPC-if_Branch\nNPC-if_JR\nNPC-if_JAL\nGRF-WD\nGRF-WA\nALU_shift\n\n\n0\nALU\nunable\nGRF-RD2\nunable\nzero_extend\nsplitter[t]\nNOT-BEQ\nNOT-JR\nNOT-JAL\nWD不是ALU结果\n-\n位移是shifter\n\n\n1\nDM\nenable\nEXT\nenable\nsign_extend\nsplitter[d]\nBEQ\nJR\nJAL\nWD不是ALU结果\n将PC+4存入寄存器的编号（31）(WA的分支)\nlui是位移16位\n\n\nALU控制0000 : +0001 : -0010 : &amp;0011 : |0100 : slt0101 : sltu1111 : 数据B向左位移shift位\ncmp控制000: &#x3D;&#x3D;001: !&#x3D;111：else\nLSOp控制sw 3’b000sh 3’b001sb 3’b010lw 3’b011lh 3’b100lb 3’b101space 3’b111\nMDUOp控制space 4’b0000mult 4’b0001multu 4’b0010div 4’b0011divu 4’b0100mfhi 4’b0101mflo 4’b0110mthi 4’b0111mtlo 4’b1000\n6.阻塞转发Tuse 和 Tnew 的分析Tuse表示数据到了 D 级之后还需要多少个周期要使用，每个指令的是固定不变的。Tnew表示数据还有多长时间产生，会随着数据的流水动态的减少。（但是大于1）Tuse表格\n\n\n\n指令\nrs_Tuse\nrt_Tuse\n\n\n\ncalc_R\n1\n1\n\n\ncalc_I\n1\n-\n\n\nmd\n1\n1\n\n\nmt\n1\n-\n\n\nload\n1\n-\n\n\nstore\n1\n2\n\n\nB\n0\n0\n\n\nJR\n0\n-\n\n\n其他的都是if_use&#x3D;0\n\n\n\n\nD级时Tnew表格\n\n\n\n指令\nTnew\n\n\n\ncalc_R\n2\n\n\ncalc_I\n2\n\n\nmf\n2\n\n\nload\n3\n\n\nlui\n2\n\n\njal\n0\n\n\n其他的都是RegWrite&#x3D;0\n\n\n\n阻塞转发的判断当Tuse≥Tnew时，可以通过转发解决；当Tuse &lt; Tnew时，必须阻塞流水线。\n阻塞操作：冻结PC寄存器（IFU_en &#x3D; ~stall &#x3D; 0）冻结D级寄存器（D_en &#x3D; ~stall &#x3D; 0）清空E级寄存器（E_clr &#x3D; stall &#x3D; 1）\n转发操作：转发需要：\n\nGRF内部转发\nD需要E、M的转发\nE需要M、W的转发\nM需要W的转发\n\n课上\n和P5差不多啦！但是不要掉以轻心，P5过了P6挂的人也有不少）\n\n依旧保证课下正确。欢迎使用伟大的cot评测机！！\n\n          \n            \n              \n              \n                cot评测机\n                伟大的评测机！！\n              \n            \n          \n\n如果P5写好了扩展性好的接口可以继续使用。如果没有写好，经过P5应该也知道要增加什么了）\n依旧是一样的课上题目分析：\n1. 计算类型形如：\nWriteData &lt;- f(GPR[rs], GPR[rt])GPR[rd] &lt;- WriteData\n做法：\n\n在控制模块中识别新指令，设置控制信号\n新增 ALU 计算类型\n新增各流水线级转发数据\n\n仿照 add 指令编写\n与P5不一样的是，会有乘除槽指令的增加（当然也可能不是乘除槽\n2. 条件跳转类型形如：\ncondition &lt;- f(GPR[rs], Ext_Ans)if condition:\tjump \t(GPR[rt] &lt;- data)else:\t(NullifyDelayedBranch)\t\n\n控制模块中设置控制信号\n计算 condition\n跳转仿照 beq\n条件写入用特判+凌驾的做法，记得改 D-E 级流水线寄存器的输入\n清空延迟槽，新增控制信号Clr_F，Clr_F为真的条件：condition为假 &amp;&amp; D级是新指令 &amp;&amp; 此时不能阻塞\n\n3. 访存类型形如：\nDMdata &lt;- DM[addr]data &lt;- f(DMdata, GPR[rt])dest_reg &lt;- f(data)GPR[dest_reg] &lt;- data\n\ndata、dest_reg 是在 W级 算出来的，M-W 流水线传 rt\nW级该指令转发 data\ndest_reg 最好在 没算出来之前都是 0，防止转发冲突\ndest_reg 的范围很重要\n比较阻塞的时候，依次比较E，M级，条件为：是新指令 &amp;&amp; 要写寄存器 &amp;&amp; 寄存器处在 dest_reg 范围内 &amp;&amp; RA！&#x3D;0 &amp;&amp; Tuse &lt; Tnew\n\n往年题依旧指路室友博客\n\n          \n            \n              \n              \n                室友博客\n                室友博客详细往年题记载！\n              \n            \n          \n\n\n\n思考题点击展开，不保证正确性，建议自己思考思考题1、为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？分离设计的原因：乘除法运算需要多个周期（乘法5周期，除法10周期），而ALU的算术逻辑指令是单周期完成。若整合进ALU，会严重拖累流水线效率。并且，乘除法器硬件结构复杂，面积大，独立模块便于优化和复用。HI、LO寄存器的作用：乘除法的结果往往是64位（32位×32位），HI存高32位，LO存低32位。专用寄存器避免占用通用寄存器堆，同时通过mfhi&#x2F;mflo指令提供访问接口。\n2、真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。一. 核心思想：用更简单的操作来实现复杂操作乘法和除法本质上可以用更基本的加法、移位和比较来实现。CPU的算术逻辑单元（ALU）最初就是被这样设计的。二. 乘法是如何实现的？我们先从最直观的算法说起。方法一：模拟手算乘法（移位相加）我们以两个4位二进制数 1011 (11) 和 1101 (13) 为例：\n        1 0 1 1   (被乘数)      x 1 1 0 1   (乘数)      ---------        1 0 1 1   (部分积1，因为乘数最低位是1)      0 0 0 0     (部分积2，因为乘数第二位是0，左移一位)    1 0 1 1       (部分积3，因为乘数第三位是1，左移两位)+ 1 0 1 1         (部分积4，因为乘数第四位是1，左移三位)---------------1 0 0 0 1 1 1 1   (结果 143)\nCPU如何用硬件实现这个过程？\n\n初始化：准备三个寄存器，一个存放被乘数，一个存放乘数，一个初始为0用于存放结果（积）。\n循环检查：· 检查乘数的最低位。· 如果为1，则将被乘数加到结果寄存器上。· 如果为0，则不加。\n移位：· 将被乘数寄存器向左移位一位（相当于值翻倍）。· 将乘数寄存器向右移位一位（这样下一次循环就能检查下一位）。\n判断终止：重复步骤2和3，直到乘数寄存器为0。这个方法的缺点是速度慢，需要N个时钟周期（N是数据的位数）。方法二：更快的现代方法为了提速，现代CPU采用了更先进的技术：· 布斯算法：一种优化算法，可以处理带符号数，并且能跳过连续的0或1，减少加法次数。· 并行乘法器&#x2F;硬件乘法器：这是现代CPU的主流方式。它不像上面那样一步一步串行计算，而是使用一个巨大的、专门设计的组合逻辑电路（比如“华莱士树”），通过多级加法器并行地计算所有部分积的和。 · 优点：速度极快！可以在1个或几个时钟周期内完成一次乘法运算。 · 缺点：电路非常复杂，晶体管数量多，功耗和芯片面积都更大。所以，当你写 a &#x3D; b * c 时，CPU几乎是在瞬间通过这个专用的硬件乘法器计算出结果的。三. 除法是如何实现的？\n\n除法是乘法的逆运算，但它更复杂，速度也更慢。\n方法一：模拟手算除法（恢复余数法）\n我们以 1111 (15) 除以 0100 (4) 为例：\n          0011 (商 = 3)        --------除数 0100)1111 (被除数)        -0100        -----          0111         -0100         -----           0011 (余数 = 3)\nCPU如何用硬件实现这个过程？\n\n初始化：准备寄存器存放被除数（和余数）、除数、商。\n对齐：将除数和被除数的最高有效位对齐。\n尝试减法：从当前被除数（或余数）中减去除数。\n判断结果：· 如果结果大于等于0，说明够减，则将商的对应位置1，并将减法结果作为新的余数。· 如果结果小于0，说明不够减，则将商的对应位置0，并恢复原来的被除数&#x2F;余数（这就是“恢复余数法”名称的由来）。\n移位：将除数右移一位，准备下一次计算。\n循环：重复步骤3-5，直到处理完所有位。\n\n这个方法同样很慢，最坏情况下需要2N个时钟周期（N是数据的位数）。\n方法二：更快的现代方法\n· 不恢复余数法&#x2F;SRT除法：这是“恢复余数法”的优化。它在发现不够减时，不去恢复余数，而是记录一个负的余数，并在下一步操作中通过加回来进行修正。这减少了很多不必要的步骤，是现代CPU常用的算法之一。· 牛顿-拉弗森迭代法：这是一种利用乘法来逼近除法结果的方法。它通过一系列迭代，快速收敛到精确的商。公式大致是：  x_{n+1} &#x3D; x_n * (2 - D * x_n) ，其中D是除数。这种方法需要快速的乘法器支持，在计算高精度除法时特别有效。· 查表法：对于某些初始近似值，CPU可能会使用一个小的、快速的查找表来获取，以加速迭代过程的启动。\n重要提示：除法在所有基本运算中是最慢的。即使是最优化的硬件实现，一次整数除法也可能需要几十个时钟周期，而一次整数乘法或加法可能只需要1个或几个周期。这就是为什么在优化代码时，要尽量避免不必要的除法操作。\n3、请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？乘除法到达E级时，产生控制信号Start&#x3D;1当start&#x3D;1时，Busy&#x3D;1持续到运算完成。在D级检测到Busy&#x3D;1或者start&#x3D;1时，同时D级是乘除法指令暂停流水线（插入气泡）。乘除法完成后Busy&#x3D;0，解除阻塞，流水线继续。\n4、请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）清晰性：m_data_byteen[3:0]明确指定写入哪些字节，避免手动拼接数据。统一性：所有存储指令（sw&#x2F;sh&#x2F;sb）共用同一写端口，通过byteen区分行为，简化DM接口。\n5、请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？读操作：从DM读出的总是整个字（32位），再由数据扩展模块提取并扩展特定字节。写操作：向DM写入的是整个字，但通过byteen控制哪些字节实际被写入。当程序频繁访问非字对齐数据时，按字节访问可避免读写整个字，减少内存带宽浪费。在稀疏数据结构（如字符数组、标志位数组）中，字节访问更高效。\n6、为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？抽象手段：1.将指令按功能分类（如算术、访存、跳转、乘除），统一生成控制信号。2.用 define，替代判断选择信号的常量规范手段：1.模块化设计，各功能模块职责单一，接口清晰。2.流水线寄存器规范化，统一传递必要信号。特点和帮助：逻辑更加简单，容易看懂，容易debug，方便修改。\n7、在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？遇到的冲突：1.控制冲突：分支指令和跳转指令导致的控制流改变。2.数据冲突：算术指令之间的读后写（RAW）冲突。（1）在E级产生结果的指令和在D级需要数据的指令之间的冲突，如add后beq（2）在M级产生结果的指令和在D级需要数据的指令之间的冲突，如lw后beq（3）在E级产生结果的指令和在E级需要数据的指令之间的冲突，如add后add（4）在M级产生结果的指令和在E级需要数据的指令之间的冲突，如lw后add（5）在M级产生结果的指令和在M级需要数据的指令之间的冲突，如lw后sw（6）乘除发指令之间的冲突4.解决：通过延迟槽，阻塞，转发的方式解决测试样例：部分测试如下表示，但是由于测试比较长，没有完全粘贴过来\nmain:    # 测试1: ALU→ALU转发    addi $1, $0, 1        # $1 = 1    addi $2, $0, 2        # $2 = 2      add  $3, $1, $2       # $3 = 3 (RAW: 需要$1,$2)    add  $4, $3, $1       # $4 = 4 (需要E级转发)        # 测试2: 加载使用冲突（需要阻塞）    addi $5, $0, 0x1000   # 数据地址    sw   $3, 0($5)        # 存储数据    lw   $6, 0($5)        # 加载数据    add  $7, $6, $1       # 需要阻塞1周期 (加载使用)        # 测试3: 多级转发    addi $8, $0, 5        # $8 = 5    add  $9, $8, $1       # $9 = 6    add  $10, $9, $2      # $10 = 8    add  $11, $10, $9     # $11 = 14        # 测试4: 转发到存储指令    addi $12, $0, 8    addi $13, $0, 9    add  $14, $12, $13    # $14 = 17    sw   $14, 4($5)       # 需要转发到存储数据    # 乘法测试    addi $1, $0, 15    addi $2, $0, 20    mult $1, $2           # 开始乘法，Busy=1        # 测试乘除阻塞 - 这些指令应该被阻塞在D级    addi $3, $0, 30       # 应该正常执行    addi $4, $0, 40       # 应该正常执行        # 在Busy期间尝试乘除指令（应该被阻塞）    mflo $5               # 应该等待乘法完成    mfhi $6               # 应该等待乘法完成        # 除法测试    addi $7, $0, 100    addi $8, $0, 7    div  $7, $8           # 开始除法，Busy=1        # 测试除法阻塞期间的指令    addi $9, $0, 50       # 正常执行    mflo $10              # 等待除法完成    mfhi $11              # 等待除法完成\n8、如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。手动构造样例策略：1.先确保每一个寄存器都可以正常使用，用lui、ori、addi、andi对每一个寄存器先赋不同值，寄存器的值保证，有正有负有0有32’HFFFF_FFFF等2.运用寄存器中的值，对每一条指令是否正常进行进行检测3.构造冒险，保证每一类冒险的情况都覆盖通过以上方式构造，同时确保每一点都覆盖所有情况，则可以基本保证覆盖了所有需要测试的情况。","categories":["计算机","co"],"tags":["北航","大二","co"]},{"title":"北航co计算机组成P4设计文档","url":"/2026/02/13/P4co/","content":"P4CPU设计文档及思考题设计草稿1.指令详解\nADD：add RD, RS, RT编码：000000 sssss ttttt ddddd 00000 100000描述：GPR[rd] &#x3D; GPR[rs] + GPR[rt]\nSUB：sub RD, RS, RT编码：000000 sssss ttttt ddddd 00000 100010描述：GPR[rd] &#x3D; GPR[rs] - GPR[rt]\nORI：ori RT, RS, IMM编码：001101 sssss ttttt iiiii iiiii iiiiii描述：GPR[rt] &#x3D; GPR[rs] | zero_extend(IMM)\nLW：lw RT, OFFSET(RS)编码：100011 sssss ttttt iiiii iiiii iiiiii描述：GPR[rt] &#x3D; MEM[GPR[rs] + sign_ext(OFFSET)]\nSW：sw RT, OFFSET(RS)编码：101011 sssss ttttt iiiii iiiii iiiiii描述：MEM[GPR[rs] + sign_ext(OFFSET)] &#x3D; GPR[rt]\nBEQ：beq RS, RT, LABEL编码：000100 sssss ttttt iiiii iiiii iiiiii描述：if GPR[rs] &#x3D;&#x3D; GPR[rt], PC &#x3D; PC + 4 + sign_ext(LABEL);  else PC &#x3D; PC + 4;\nlui：lui RT, IMM编码：001111 00000 ttttt iiiii iiiii iiiiii描述：GPR[rt] &#x3D; sign_ext(IMM) &lt;&lt; 16;\njal: jal target编码：000011 iiiii iiiii iiiii iiiii iiiiii描述：GPR[31] &#x3D; PC + 4;  PC &#x3D; PC[31,28]||instr_index||00\njr: jr rs编码：000000 sssss 00000 00000 00000 001000描述：PC &#x3D; GPR[rs]\nnop：nop编码：000000 00000 00000 00000 00000 000000描述：GPR[0] &#x3D; GPR[0]\n\n2.各部件接口设计NPC\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nPC\nI\n31:0\n前一拍指令地址\n\n\noffset\nI\n31:0\n用于计算B类指令跳转地址\n\n\nIns_26\nI\n25:0\n用于计算J、JAL跳转地址\n\n\nRa\nI\n31:0\n用于读取JR、JALR中寄存器存储的地址\n\n\nif_Branch\nI\n1\n用于判断是否为B类指令\n\n\nif_JR\nI\n1\n用于判断是否为J、JR指令\n\n\nNext_PC\nO\n31:0\n下一拍指令地址\n\n\nPC+4\nO\n31:0\n上一拍指令地址+4，用于JAL、JALR地址存储\n\n\nIFU\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nclk\nI\n1\n时钟信号\n\n\nReset\nI\n1\n同步复位信号\n\n\nNext_PC\nI\n31:0\n计算出的下一拍指令地址\n\n\nPC\nO\n31:0\n当前指令地址\n\n\nInstr\nO\n31:0\n当前指令内容\n\n\nGRF\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nRA1\nI\n4:0\n读寄存器1地址\n\n\nRA2\nI\n4:0\n读寄存器2地址\n\n\nWA\nI\n4:0\n写寄存器地址\n\n\nWD\nI\n31:0\n写寄存器数据\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n同步复位信号\n\n\nRegWrite\nI\n1\n写寄存器控制信号\n\n\nRD1\nO\n31:0\n读寄存器1数据\n\n\nRD2\nO\n31:0\n读寄存器2数据\n\n\nALU\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nALU_Op\nI\n3:0\nALU操作码\n\n\nSrc_A\nI\n31:0\nALU输入A数据\n\n\nSrc_B\nI\n31:0\nALU输入B数据\n\n\nshift\nI\n5:0\n位移量（对B数据进行位移）\n\n\nAequalB\nO\n1\nALU输出结果是否等于输入B数据\n\n\nAsmallB\nO\n1\nALU输出结果是否小于输入B数据\n\n\nAbigB\nO\n1\nALU输出结果是否大于输入B数据\n\n\nALU_Result\nO\n31:0\nALU输出结果\n\n\nDM\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nclk\nI\n1\n时钟信号\n\n\nReset\nI\n1\n同步复位信号\n\n\nMemWrite\nI\n1\n写内存控制信号\n\n\nA\nI\n31:0\n写地址\n\n\nWD\nI\n31:0\n写数据\n\n\nRD\nO\n31:0\n读数据\n\n\nEXT\n\n\n接口名称\n输入或输出\n位宽\n描述\n\n\n\nImm\nI\n15:0\n扩展前的立即数\n\n\nif_sign\nI\n1\n是否为有符号扩展\n\n\noffset\nO\n31:0\n扩展后的立即数\n\n\n3.数据通路设计以下表示每个部分应该如何连接，连接在mips顶层中，本人采取的形式是：\nwire [31:0] NPC_PC;wire [31:0] NPC_offset;wire [25:0] NPC_Ins_26;wire [31:0] NPC_Ra;wire NPC_if_Branch;wire NPC_if_jr;wire NPC_if_jal;wire [31:0] NPC_Next_PC; //Owire [31:0] NPC_PC_4; //ONPC NPC(NPC_PC , NPC_offset , NPC_Ins_26 , NPC_Ra , NPC_if_Branch , NPC_if_jr , NPC_if_jal , NPC_Next_PC , NPC_PC_4);assign NPC_PC = IFU_PC;assign NPC_offset = EXT_offset;assign NPC_Ins_26 = IFU_Instr[25:0];assign NPC_Ra = GRF_RD1;assign NPC_if_Branch = Branch &amp; ALU_AequalB;assign NPC_if_jr = JR;assign NPC_if_jal = JAL;\n\n此形式虽复杂但是方便debug）\nNPC\n\n\n操作\nPC\noffset\nIns_26\nRA\nif_Branch\nif_jr\nif_jal\n\n\n\nall\nIFU\nEXT\nsplitter\nGRF\ncontrol\ncontrol\ncontrol\n\n\nIFU\n\n\n操作\nclk\nReset\nNext_PC\n\n\n\nall\nclk\nreset\nNPC\n\n\nGRF\n\n\n操作\nclk\nReset\nRA1\nRA2\nWA\nWD\nRegWrite\n\n\n\nadd\nclk\nreset\nsplitter[s]\nsplitter[t]\nsplitter[d]\nALU\ncontrol\n\n\nsub\nclk\nreset\nsplitter[s]\nsplitter[t]\nsplitter[d]\nALU\ncontrol\n\n\nori\nclk\nreset\nsplitter[s]\n-\nsplitter[t]\nALU\ncontrol\n\n\nlw\nclk\nreset\nsplitter[s]\n-\nsplitter[t]\nDM\ncontrol\n\n\nsw\nclk\nreset\nsplitter[s]\nsplitter[t]\n-\n-\ncontrol\n\n\nbeq\nclk\nreset\nsplitter[s]\nsplitter[t]\n-\n-\ncontrol\n\n\nlui\nclk\nreset\n-\n-\nsplitter[t]\nALU\ncontrol\n\n\njal\nclk\nreset\n-\n-\n31\nNPC\ncontrol\n\n\njr\nclk\nreset\nsplitter[s]\n-\n-\n-\ncontrol\n\n\nALU\n\n\n操作\nALU_Op\nSrc_A\nSrc_B\nshift\n\n\n\nadd\ncontrol\nGRF-RD1\nGRF-RD2\n-\n\n\nsub\ncontrol\nGRF-RD1\nGRF-RD2\n-\n\n\nori\ncontrol\nGRF-RD1\nEXT\n-\n\n\nlw\ncontrol\nGRF-RD1\nEXT\n-\n\n\nsw\ncontrol\nGRF-RD1\nEXT\n-\n\n\nbeq\ncontrol\nGRF-RD1\nGRF-RD2\n-\n\n\nlui\ncontrol\n-\nEXT\n16\n\n\njal\n-\n-\n-\n-\n\n\njr\n-\n-\n-\n-\n\n\nDM\n\n\n操作\nclk\nReset\nMemWrite\nA\nWD\n\n\n\nlw\nclk\nreset\ncontrol\nALU-Result\n-\n\n\nsw\nclk\nreset\ncontrol\nALU-Result\nGRF-RD2\n\n\nelse\n-\n-\n-\n-\n-\n\n\nEXT\n\n\n操作\nImm\nif_sign\n\n\n\nall\nsplitter[i]\ncontrol\n\n\n4.控制信号总控制\n\n\n数值\nMemToReg\nMemWrite\nALUSrc\nRegWrite\nsignedEXT\nRegDst\nif_Branch\nif_JR\nif_JAL\nAddrToReg\nRalink\nif_lui\n\n\n\n控制的位置\nGRF-WD\nDM-MemWrite\nALU-SrcB\nGRF-RegWrite\nEXT-if_sign\nGRF-WA\nNPC-if_Branch\nNPC-if_JR\nNPC-if_JAL\nGRF-WD\nGRF-WA\nALU_shift\n\n\n0\nALU\nunable\nGRF-RD2\nunable\nzero_extend\nsplitter[t]\nNOT-BEQ\nNOT-JR\nNOT-JAL\n-\n-\n-\n\n\n1\nDM\nenable\nEXT\nenable\nsign_extend\nsplitter[d]\nBEQ\nJR\nJAL\n将PC+4存入寄存器\n将PC+4存入寄存器的编号（31）\n偏移量16\n\n\nALU控制0000 : +0001 : -0010 : |0011 : 数据B向左位移shift位\n指令对应控制信号\n\n\n指令\nALU操作\nALUcontrol\nMemToReg\nMemWrite\nALUSrc\nRegWrite\nsignedEXT\nRegDst\nif_Branch\nif_JR\nif_JAL\nAddrToReg\nRalink\nif_lui\n\n\n\nadd\n+\n0000\n0\n0\n0\n1\n-\n1\n0\n0\n0\n0\n0\n0\n\n\nsub\n-\n0001\n0\n0\n0\n1\n-\n1\n0\n0\n0\n0\n0\n0\n\n\nori\nor\n0010\n0\n0\n1\n1\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nlw\n+\n0000\n1\n0\n1\n1\n1\n0\n0\n0\n0\n0\n0\n0\n\n\nsw\n+\n0000\n-\n1\n1\n0\n1\n0\n0\n0\n0\n0\n0\n0\n\n\nbeq\n&#x3D;&#x3D;\n-\n0\n0\n0\n0\n1\n-\n1\n0\n0\n0\n0\n0\n\n\nlui\n&lt;&lt;\n0011\n0\n0\n1\n1\n-\n0\n0\n0\n0\n0\n0\n1\n\n\njal\n-\n-\n0\n0\n-\n1\n-\n0\n0\n0\n1\n1\n1\n0\n\n\njr\n-\n-\n0\n0\n-\n0\n-\n-\n0\n1\n0\n0\n0\n0\n\n\n课上采用P3的思路可以继续解决\n往年题可以看推荐题，同时指路室友博客\n\n          \n            \n              \n              \n                室友博客\n                室友博客详细往年题记载！\n              \n            \n          \n\n\n\n思考题点击展开，不保证正确性，建议自己思考思考题1.阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？addr来源：来自ALU计算出的有效地址，ALU计算出的32位地址取其中的[11:2]位。ALU计算出的有效地址是按字节寻址（地址最低2位[1:0]用于字节选择，[13:2]用于字选择），而在Verilog中构建的DM是按字寻址的。所以，需要将ALU计算出的地址左移两位，即除以四，才是DM中的地址。另外，DM容量是32bit × 1024字，可知，字地址有10位。\n2.思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。1.指令对应的控制信号如何取值\ncase(instr)begin    `add:    begin        ALUcontrol &lt;= 0;        MemToReg &lt;= 0;        MemWrite &lt;= 0;        ALUSrc &lt;= 0;        RegWrite &lt;= 1;        signedEXT &lt;= 0;        RegDst &lt;= 1;        if_Branch &lt;= 0;        if_JR &lt;= 0;        if_JAL &lt;= 0;        AddrToReg &lt;= 0;        Ralink &lt;= 0;        if_lui &lt;= 0;    end    ……    default: ;endcase\n2.控制信号每种取值所对应的指令\nassign MemTOReg = (All_input == `lw);assign MemWrite = (All_input == `sw);assign ALUSrc = (All_input == `ori)|(All_input == `lw)|(All_input == `sw)|(All_input == `lui);assign RegWrite = (All_input == `R)|(All_input == `ori)|(All_input == `lw)|(All_input == `lui)|(All_input == `jal);assign signedEXT = (All_input == `lw)|(All_input == `sw)|(All_input == `beq);assign RegDst = (All_input == `R);assign Branch = (All_input == `beq);assign JR = (All_input == `R) &amp;&amp; ((R_input == `jr));assign JAL = (All_input == `jal);assign AddrToReg = (All_input == `jal);assign Ralink = (All_input == `jal);assign lui = (All_input == `lui);assign ALUop = (All_input == `ori)? 4&#x27;b0010:               (All_input == `lw)? 4&#x27;b0000:\t\t\t\t\t(All_input == `sw)? 4&#x27;b0000:\t\t\t\t\t(All_input == `lui)? 4&#x27;b0011:\t\t\t\t\t(All_input == `R)? (R_input == `add)? 4&#x27;b0000:\t\t\t\t\t\t\t\t\t\t\t (R_input == `sub)? 4&#x27;b0001:\t\t\t\t\t\t\t\t\t       4&#x27;b0011\t\t\t\t\t:4&#x27;b0011;\n3.优劣对比\n\n\n\n特性\n方式一（查表式）\n方式二（分布式）\n\n\n\n可读性\n高，结构清晰\n低，逻辑分散\n\n\n可维护性\n高，修改集中\n低，修改分散\n\n\n扩展性\n中等\n高，易于添加新信号\n\n\n综合结果\n可能生成较大多路器\n逻辑更优化\n\n\n调试难度\n容易调试\n较难调试\n\n\n3.在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。同步复位，clk优先级更高\t异步复位，reset优先级更高\n4.C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。“ADDU performs the same arithmetic operation but does not trap on overflow”add与addu指令的大致功能是一样的。其区别是add在溢出时，触发Integer Overflow异常；而addu忽略溢出，不产生异常。因此在忽略溢出的C语言环境下，两条指令完全等价。同理，addi与addiu在忽略溢出时也是等价的。","categories":["计算机","co"],"tags":["北航","大二","co"]},{"title":"北航co计算机组成P7debug分享和思考题","url":"/2026/02/13/P7%20debug%E5%88%86%E4%BA%AB/","content":"写在前面：本人P7设计文档和P6大差不差，所以就放debug分享了，思考题附在了后面\n\nP7 debug分享一.  易错分析有点啰嗦，按需阅读\n首先，先让我们理清楚P7在P6的基础上增加了什么，以及哪些比较容易错。与此相对应的，我们在看P7的bug前请保证P6代码部分已经没有问题。\n（以下实现都可能有其他情况）\nCPU内部：\nF级：\n当D级指令是eret时，F级下一个PC为EPC\n\n若采用不清空 eret 后面的延迟槽的办法，F 级当前指令即为 EPC\n\n\n当Req == 1的时候，PC &lt;= 32&#39;H00004180\n易错点：\n\nReq和reset和stall之间存在优先级\n请确保代码符合：\nif(reset == 1)\tbegin\t\t……\tend\telse\tbegin\t\tif(Req == 1)\t\tbegin\t\t\tPC &lt;= 32&#x27;H00004180;\t\tend\t\telse\t\tbegin\t\t\tif(stall == 1)\t\t\tbegin\t\t\t\t……\t\t\tend\t\t\telse\t\t\tbegin\t\t\t\t……\t\t\tend\t\tend\tend\n\n\nReq == 1时除了 W 级以外（以 CP0 设在 M 级为例）全部流水级的 PC 均&lt;= 32&#39;H00004180，正常情况下宏观 PC 应连续三个周期保持在 32&#39;H00004180\n\n\n\n\n增加相应的检测异常的部分。此时可以检测出来的异常有AdEL\n易错点：\n\nAdEL错误发生后请把指令清空，只 需要把instr变成0即可\n在判断地址时，请和指导书要求保持一致，确保&lt;并没有写成&lt;=等等\n\n\n连线部分：\n\n\n\n新增接口\n连线部分\n\n\n\nF_EPC\nCP0_EPCOut\n\n\nif_eret\nD_control_iferet（有其他实现）\n\n\nF_Req\nCP0_Req\n\n\n其余部分实现差异可能较大，无论如何请保证连线正确。\n\n\n\nFtoD流水线寄存器：\n增加对Req == 1的相应部分\n易错点：\n\n把PC改为32&#39;H00004180，而不是清零。\n仍然是保证Req和reset和stall之间的优先级\n其余清零即可\n\n\n当D级是eret指令时清空延迟槽，保持PC不变（有其他实现方式）\n易错点：\n\n不阻塞的时候才可以清空延迟槽\nif(stall == 1)\tbegin\t\t……\tend \telse\tbegin\t\tif(if_eret == 1)\t\tbegin\t\t\t……\t\tend\t\telse\t\tbegin\t\t\t……\t\tend\tend\n\n\n增加BD、EXCcode的流水\n\n各部分的更改：reset将PC改为32&#39;H00003000，其余清零即可；Req将PC改为32&#39;H00004180，其余清零即可；stall将所有值保持不变；清空延迟槽保持PC不变,其余清零即可。\n\n注意在阻塞注入空泡时 BD 需正常流水（而非清零或保持当前值）\n\n\n连线部分\n\n\n\n新增接口\n连线部分\n\n\n\nReq\nCP0_Req\n\n\nif_eret（如果需要）\nD_control_iferet（有其他实现）\n\n\nBD\n&#96;D_control_Branch\n\n\nEXCcode\nF_EXCcode\n\n\ninstr\n注意传异常处理之后清零的instr\n\n\n其余部分实现差异可能较大，无论如何请保证连线正确。\n\n\n\nD级：\nD级需要信号能够反馈当前是否为eret(给F) 和 mtc0(为了暴力阻塞)\n\n原始控制信号部分增加RegWrite = …… | mfc0 (控制信号以分布式为例)\n易错点：\n\n在判断指令mfc0和mtc0时请注意它的特殊性(rs == mfc0)\n\n\n增加相应的检测异常的部分。此时可以检测出来的异常有Syscall和RI\n易错点：\n\n检测到异常发生后请把指令清空，只 需要把IR变成0即可\n虽然我们对nop啥都不干，但是它是已知指令: (\n\n\n**阻塞阻塞阻塞！**当D级是eret时，如果E级和M级是mtc0，记得暴力阻塞一下。(cp0实现内部转发+E级到D级转发  &#x2F;  cp0实现内部转发+E级与D级阻塞也可以，但有可能会导致对拍不一致)\n\n给新增指令增加Tuse和Tnew\n\n连线部分\n好像没有特别需要注意的连线，提一句的就是把E级和M级的if_mtc0传过来方便阻塞。\n\n\n\nDtoE流水线寄存器：\n增加对指令是否是mtc0的流水，用于暴力阻塞\n\n增加BD、EXCcode的流水\n\n增加对Req == 1的相应部分\n易错点：\n\n仍然是保证Req和reset和stall之间的优先级\n\n\n各部分的更改：reset将PC改为32&#39;H00003000，其余清零即可；Req将PC改为32&#39;H00004180，其余清零即可；stall时PC改为当前在D级指令的新PC，BD改为当前在D级指令的新BD\n\n连线部分\n\nEXCcode的流水，优先F级的异常，若F级没有异常再流水D级的异常（没有异常可以认为是0），如：EXCcode = (F_EXCcode != 0)? F_EXCcode : D_EXCcode;\n\nBD连接FtoD流水线寄存器输出的BD 即可\n\nif_mtc0连接D_control_ifmtc0（有其他实现）\n\ninstr注意发生异常后清零\n\nRegWrite注意发生异常后清零\n\n\n\n\n\nE级：\n​     在ALU中判断是否溢出，采用指令集的方法即可\nif(temp[32] != temp[31])\tbegin\t\toverflow = 1;\tend\telse\tbegin\t\toverflow = 0;\tend\n\nMDU模块中增加Req。当Req为1的时候，乘除槽中原本的计算继续计算，但是不可以加入新的计算。（不可以取巧，比如室友想反正eret回到乘除指令都需要写入，那直接写入但先不开启延迟倒计时也没有区别，然而是异常处理程序部分会拿出LO和HI进行保存，这个时候就WA了）（本人在这里卡了好久，可能是乘除槽实现问题，如果对自己的实现不把握的话，可以单独对MDU模块进行仿真测试）\n\n增加相应的检测异常的部分。此时可以检测出来的异常有AdEL、AdES、Ov(也可以在M级对这些异常进行检测，但是要注意异常的指令不可以对Bridge以及后续W级的REG产生任何影响)\n易错点：\n\n检测到异常发生后可以选择把指令清空，防止对后续DM和寄存器产生影响，只 需要把IR变成0即可（这样做其实有点风险）\n\n另一种实现思路是保留完整的异常指令一直到 M 级，在 Req = 1 的时候禁访存（手动把 byteen 搞成 0）\n\n\n注意这里不能因为 GRF 在 CP0 之后就不管 GRF，如果不把受害指令清零的话错误操作照样会流水到 W 级                                                            \n\n\n对地址的判断较为繁琐,高频易错，细致细致，一定对着指导书的写（见过不少AdEL、AdES判断错误的都是断章取义了）。确保符号正确，&lt;并没有写成&lt;=，||没有写成&amp;&amp;等等。确保地址数据正确，如计时器的Count寄存器是32&#39;H0000_7F08和32&#39;H0000_7F18（见证了室友写成32&#39;H0000_7F28）\n\n\n\n连线部分\n把MDU_Req连接CP0_Req\n\n\n\nEtoM流水线寄存器：\n增加对指令是否是mtc0的流水，用于暴力阻塞\n\n增加BD、EXCcode的流水\n\n增加对Req == 1的相应部分\n易错点：\n\n仍然是保证Req和reset之间的优先级\n\n\n各部分的更改：reset将PC改为32&#39;H00003000，其余清零即可；Req将PC改为32&#39;H00004180，其余清零即可；\n\n连线部分\n\nEXCcode的流水，优先D级的异常，若D级没有异常再流水E级的异常（没有异常可以认为是0），如：EXCcode = (D_EXCcode != 0)? D_EXCcode : E_EXCcode;\n\nBD连接DtoE流水线寄存器输出的BD 即可\n\nif_mtc0连接DtoE流水线寄存器输出的if_mtc0 即可（有其他实现）\n\ninstr注意发生异常后清零\n\nRegWrite注意发生异常后清零\n\n 如果 Regwrite 不是流水的的话，在 MtoW 把 IR 清零也是一样的\n\n\n异常指令保留到 MtoW 就可以放心清零了，因为  W 级不可能加异常的\n\n\n\n\n\n\nM级：\n本人将CP0放在了M级，由于CP0的复杂性本人打算等会讲\n\n在M_control中增加CP0OuttoReg、CP0en、iferet输出\nassign CP0OutToReg = mfc0;assign CP0en = mtc0;assign iferet = eret;\n\n连线部分\n异常的指令byteen一定要保证是0。\n于是，现在我们基本保证了异常指令不会影响内存和寄存器。但是！**我们还需要保证外部中断到来的时候，当前指令也不会影响到内存和寄存器！**所以，请在CP0_Req == 1时，保证byteen是0。\n\n\n\nMtoW流水线寄存器和W级：\n没有什么特别需要修改的，只需要注意在CP0_Req == 1时，保证RegWrite是0。\n\n\nCP0：\nCP0理论上可以说是各不相同，建议没把握可以对CP0模块进行单独仿真\n\n注意有异常中断的时候，Req也不一定要更改，大致要求是\nassign inter_req = (|(HWInt &amp; SR_IM)) &amp; SR_IE &amp; (!SR_EXL);assign exc_req   = (EXcCodeIn != 5&#x27;d0) &amp; (!SR_EXL);assign Req       = inter_req | exc_req;\n\n注意外部中断到来的时候，mtc0也不应该修改CP0寄存器\n所以mtc0也不应该修改CP0寄存器的条件是if((en == 1) &amp;&amp; (Req == 0))\n\n外部中断优先级高于异常，此时注意Cause_ExcCode存入的是0\n\n本人的实现出现了一个奇怪的bug，在这里分享一下。和室友探讨以后发现这是一个很奇怪的问题，至今也没有完全理解，欢迎大家找我探讨！\n\n请看完再决定自己的代码在这部分有没有问题，因为。。\n\n以下三个版本可能看着没有区别。所以我决定把我的仿真结果跟在后面，以下是tb文件（数据全乱编的，可能不符合CPU逻辑，但是我觉得对CP0测试应该没有问题）\nmodule cp0_test;\t// Inputs\treg clk;\treg reset;\treg en;\treg [4:0] CP0Add;\treg [31:0] CP0In;\treg [31:0] VPC;\treg BDIn;\treg [4:0] EXcCodeIn;\treg [5:0] HWInt;\treg EXLClr;\t// Outputs\twire [31:0] CP0Out;\twire [31:0] EPCOut;\twire Req;\t// Instantiate the Unit Under Test (UUT)\tCP0 uut (\t\t.clk(clk), \t\t.reset(reset), \t\t.en(en), \t\t.CP0Add(CP0Add), \t\t.CP0In(CP0In), \t\t.CP0Out(CP0Out), \t\t.VPC(VPC), \t\t.BDIn(BDIn), \t\t.EXcCodeIn(EXcCodeIn), \t\t.HWInt(HWInt), \t\t.EXLClr(EXLClr), \t\t.EPCOut(EPCOut), \t\t.Req(Req)\t);\tinitial begin\t\t// Initialize Inputs\t\tclk = 1;\t\treset = 1;\t\ten = 0;\t\tCP0Add = 0;\t\tCP0In = 0;\t\tVPC = 0;\t\tBDIn = 0;\t\tEXcCodeIn = 0;\t\tHWInt = 0;\t\tEXLClr = 0;\t\t\t\t#5;\t\treset = 0;\t\t\t\t#5;\t\tVPC = 10;\t\tBDIn = 1;\t\tEXcCodeIn = 4;\t\tHWInt = 0;\t\tEXLClr = 0;\t\t\t\t#10;\t\tVPC = 14;\t\tBDIn = 0;\t\tEXcCodeIn = 0;\t\tHWInt = 0;\t\tEXLClr = 0;\tend    \talways #5 clk = ~clk;endmodule\n\n我的初版是：\nif(Req == 1)begin\t`SR_EXL\t \t   &lt;= 1&#x27;b1;\t`Cause_BD\t   &lt;= BDIn;\t`Cause_ExcCode &lt;= (inter_req)? 5&#x27;d0 : EXcCodeIn;\t`EPC \t\t   &lt;= (BDIn == 1)? (VPC - 32&#x27;d4) : VPC;end\t`Cause_IP \t   &lt;= HWInt;\n\n但是我对CP0模块进行单独仿真时发现，这个时候EPC已经是错误指令的下一个周期的对应值了\n如下图所示：\n图1\n\np. s.  这个明显应该是错误的，但是这个错误当时并没有被COT检测出来（）\n\n我的初步理解是，我的Req并没有在时钟上升沿到来的时候及时改变，即10ns时钟上升沿到来时，Req没有及时变为1，所以if(Req == 1)这一块代码没有在这一周期运行；在20ns时钟上升沿到来时，Req没有及时变为0，所以if(Req == 1)这一块代码在这一周期运行了\n于是改成了\nif(((|(HWInt &amp; `SR_IM)) &amp; `SR_IE &amp; (!`SR_EXL)) || ((EXcCodeIn != 5&#x27;d0) &amp; (!`SR_EXL)))begin\t`SR_EXL \t   &lt;= 1&#x27;b1;\t`Cause_BD      &lt;= BDIn;\t`Cause_ExcCode &lt;= ((|(HWInt &amp; `SR_IM)) &amp; `SR_IE &amp; (!`SR_EXL))? 5&#x27;d0 : EXcCodeIn;\t`EPC           &lt;= (BDIn == 1)? (VPC - 32&#x27;d4) : VPC;end\t`Cause_IP      &lt;= HWInt;\n\n对照一下，你会发现，其实我就是把Req改成了组成他的部分。但是仿真结果出现了巨大改变：\n图2\n诶EPC对了！\n此时整体结果应该是没有任何问题了\n但是仔细观察，你会发现，诶？我Req怎么没变过！？\n我的理解是，Req改变条件中有SR_EXL，而运行if(((|(HWInt &amp; SR_IM)) &amp; SR_IE &amp; (!SR_EXL)) || ((EXcCodeIn !&#x3D; 5’d0) &amp; (!SR_EXL)))模块的时候快速更改了SR_EXL，于是出现了Req昙花一现式改变的情况\n所以看似没变，只是Req迅速改变为1又迅速改变为0，仿真没有体现出来\n为了能够体现出来Req的改变，于是有了第三版：\nif(Req == 1)begin\t`SR_EXL        &lt;= 1&#x27;b1;endif(((|(HWInt &amp; `SR_IM)) &amp; `SR_IE &amp; (!`SR_EXL)) || ((EXcCodeIn != 5&#x27;d0) &amp; (!`SR_EXL)))begin\t`Cause_BD      &lt;= BDIn;\t`Cause_ExcCode &lt;= ((|(HWInt &amp; `SR_IM)) &amp; `SR_IE &amp; (!`SR_EXL))? 5&#x27;d0 : EXcCodeIn;\t`EPC           &lt;= (BDIn == 1)? (VPC - 32&#x27;d4) : VPC;end\t`Cause_IP      &lt;= HWInt;\n\n然后就没有问题了：\n\n这样看起来实现得很丑陋，但是可行，但是丑陋。\n\n当你看完这段，你去看自己的代码，大部分人可能会想，我不会是错的吧（本人室友就这想了）\n然而是！然而是！\n她与我的第一版实现几乎一致，但是仿真结果如第二版所示，也就是没有问题！\n以下是她这部分的代码：\n`CAUSE_IP &lt;= HwInt; if (Req) begin\t`CAUSE_BD       &lt;= BD;\t`SR_EXL         &lt;= 1&#x27;b1;\tEPC             &lt;= (BD) ? (Vpc - 4) : Vpc;\t`CAUSE_EXCCODE  &lt;= (interruptJudge) ? 5&#x27;b00 : excCode;end \n\n仿真结果是：\n\nEPC正常改变了！\n仔细比较我们CP0的区别，只有：\n我在CP0开了数组，实现所有寄存器\nreg [31:0] mem [0:31];\n\n而她只实现了部分寄存器\nreg [31:0] SR;reg [31:0] CAUSE;reg [31:0] EPC;reg [31:0] PRID;\n\n但感觉应该不是这个区别导致的，并没有理解为什么: (\n有想法的话欢迎探讨！\n\n\nReq只会产生一个周期，在中断处理程序过程中一直是1的是SR_EXL，直到eret到达M级使得(EXLClr == 1)，SR_EXL &lt;= 1&#39;b0;\n\n连线部分\n\n\n\n接口\n连线\n\n\n\nCP0_en\nM_control_CP0en\n\n\nCP0Add\nIR[rd]\n\n\nCP0In\nM级转发后的GRF[rt]\n\n\nCP0_VPC\nEtoM_PC\n\n\nCP0_BDIn\nEtoM_BD\n\n\nCP0_EXcCodeIn\nEtoM_EXCcode\n\n\nCP0_HWInt\nCPU_HWInt\n\n\nCP0_EXLClr\nM_control_iferet\n\n\n\n\n\nCPU和外部的连线：额。。其实感觉只要内部实现了，与外部连线传输的数据就不怎么需要更改。还是强调一下异常中断时，当前指令也不应该影响到内存和寄存器，保证byteen == 0和RegWrite == 0。另外注意传输CP0所在一级的PC作为宏观PC。\n\n\nBridge：同样也是各不相同的实现方式，没把握可以对该模块进行单独仿真，现说明一些易错：\n\n地址地址地址。\n\n\n\n\n地址\n数值\n\n\n\nDM\n(A &gt;= 32&#39;H0000_0000 &amp;&amp; A &lt;= 32&#39;H0000_2FFF)\n\n\nT0\n(A &gt;= 32&#39;H0000_7F00 &amp;&amp; A &lt;= 32&#39;H0000_7F0B)\n\n\nT1\n(A &gt;= 32&#39;H0000_7F10 &amp;&amp; A &lt;= 32&#39;H0000_7F1B)\n\n\nInt\n(A &gt;= 32&#39;H0000_7F20 &amp;&amp; A &lt;= 32&#39;H0000_7F23)\n\n\n\n保证Timer0 输出的中断信号接入 HWInt[0] (最低中断位)，Timer1 输出的中断信号接入 HWInt[1]，来自中断发生器的中断信号接入 HWInt[2]。（小心接错位）\nassign HWInt = &#123;3&#x27;b000, interrupt, Timer1_IRQ, Timer0_IRQ&#125;;\n\nTimer：课程组已经给了该板块了，但是但是不仔细阅读会出错。传入的地址是30位input [31:2] Addr ！！！ \n二.  对拍！本人不会搭建评测机，但是我们有伟大的 COT评测机感谢学长感谢学长！（我也用过cokiller，我们的输出和它mars对拍会多很多行，而且好像无法和同学对拍，所以就不过多叙述了）但是COT对拍会有一点差异性：分为和mars对拍、和同学对拍进行讲述吧！\n\n和mars对拍\nmars在遇到sb和lb指令读取32&#39;H0000_2FFF的时候会标记为异常指令，大致情形如下：\nMars: &quot;@00004180: $26 &lt;= 00000414&quot;P7: &quot;@0000388c: *00002ffc &lt;= 69000000&quot;\n\nmars在读取计时器的Count寄存器时，会和我们有所不同，大致情形如下：\nMips Code: &quot;lw $15, 61($20)&quot; in line 285Mars: &quot;@00003400: $15 &lt;= ffffffff&quot;P7: &quot;@00003400: $15 &lt;= 00000000&quot;\n\n仔细debug然后会发现lw读取的是Count寄存器\n\n\n\n和同学对拍由于每个人实现的不一样，会导致对拍的差异性：\n\neret实现的不一样\n\n清空延迟槽\n\n通过一个多路选择器，当D时eret时直接将F的PC改为EPC\n\n\n\n\n​       每一次中断异常，后者会比前者少一个周期，这样会导致到后期Timer产生的中断完全对不上\n\n阻塞转发实现的不一样。\n这个就比较多样性了，如lui的Tnew其实可以是1，会导致周期差异。同样面对mtc0和eret暴力阻塞还是转发，也会导致周期差异\n（甚至你乘除槽延长的时间是不是5&#x2F;10周期也会有影响）\n\n\n对拍具体差异如下：\nverilog@P7_1 execute: &quot;mfc0 $k0, $13&quot; in line 1244verilog@P7_1: &quot;@00004180: $26 &lt;= 00000410&quot;verilog@P7_2 execute: &quot;mfc0 $k0, $13&quot; in line 1244verilog@P7_2: &quot;@00004180: $26 &lt;= 00000010&quot;\n\n此时具体去看会发现是Cause_IP的不同，再具体去查看就会发现此时timer_IRQ不一样，然后就会发现其实运行时间有很大差异。\n\ncot不足经过第一次强测，我们发现cot评测机没有BD位输出错误进行测试。具体是，没有对jr指令后延迟槽指令是否出现中断异常（涉及到BD位输出错误）进行测试。而本人之前也出现了cot评测全过但是弱测没过的情况: ( 。不过真的很感谢学长的cot评测机了。\n\np. s. 据我所知，上一届强测没有检测Timer有关错误，所以拿到的上一届强测过了的代码不一定完全正确哦~\n\n\n\n三.  debug思路分享当我们发现cot评测机wa之后，我们可以选择吧code.txt放到我们的P7文件夹中进行仿真。code.txt一般比较长，记事本左上角的查找功能可以帮助我们找到我们错的那一行，然后观察上下文。mars程序也可以送给ai让他给我们标上PC。如果PC在4180那一段，基本是找不到bug的，我们需要知道异常中断之前发生了什么，可以往回找PC到3xxx，找对应寄存器的错误，然后记住PC，在仿真里面找到他，如果是寄存器，就一层一层展开路径上的所有模块看哪个结果不符合预期（可以把每一级的PC都拎出来方便观察）。如果是内存的话，就要算一下理想中是读那一段的内存，然后再一层一层展开。然后就是对着错误模块干瞪眼了，当然对错误模块进行单独仿真也不错。\n四. 最后感谢我伟大善良智慧的室友大人给予本篇文章的众多意见和想法！\n有任何想法意见欢迎讨论。有任何错误欢迎纠正！\n祝大家co顺利！\n思考题点击展开，不保证正确性，建议自己思考思考题1、请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？鼠标和键盘作为外设，其输入信号通常通过中断机制被 CPU 知晓。具体过程如下：硬件接口：鼠标和键盘通过 USB、PS&#x2F;2 等接口连接到计算机系统。中断信号：当用户按下按键或移动鼠标时，外设控制器会向 CPU 发送一个外部中断信号。中断控制器：该信号通常先由中断控制器（如 8259A 或 APIC）管理，设置相应的中断标志。CPU 响应：CPU 在每条指令执行结束时检查是否有中断请求。若有，则暂停当前程序，保存现场，跳转到中断服务程序入口地址。中断服务程序：读取外设数据寄存器，获取输入内容，进行处理。\n2、请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）CPU 处理中断异常必须是固定入口地址的原因在于：1.硬件设计简化：固定入口地址使得 CPU 硬件实现简单，无需额外寄存器存储用户提供的入口地址。2.系统安全与控制：如果允许用户自定义入口地址，可能出现以下问题：*恶意代码执行：用户可能将入口地址指向恶意代码，破坏系统。*系统一致性破坏：用户程序可能未正确处理异常，导致系统状态不一致。*优先级与嵌套问题：用户程序可能未正确处理中断嵌套或优先级，导致系统死锁或响应异常。若支持用户自定义入口地址，虽能提供灵活性，但会引入安全性和可靠性风险，需额外的硬件保护机制（如特权模式、内存保护）来限制。\n3、为何与外设通信需要 Bridge？与外设通信需要系统桥（Bridge）的原因包括：1.接口统一化：外设种类繁多，接口各异。系统桥提供统一的读写接口（如内存映射 I&#x2F;O），使 CPU 可以像访问内存一样访问外设。2.简化 CPU 设计：CPU 无需为每种外设设计专用指令或接口，符合“高内聚、低耦合”设计原则。3.地址映射与解码：系统桥负责将 CPU 发出的地址映射到相应的外设，并处理读写时序与协议转换。4.扩展性与模块化：新增外设时只需接入系统桥，无需修改 CPU 设计。\n4、请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。模式0下的中断信号将持续有效，直至控制寄存器中的中断屏蔽位被设置为0。不同于模式0，模式1下计数器每次计数循环中只产生一周期的中断信号。\n5、倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？(一) 如果中断信号到达时，宏观 PC 所在的流水级是一条空泡指令（NOP，所有信息为空），会发生：无法确定异常入口：空泡指令没有有效的 PC 值，导致无法正确写入 EPC，也无法确定异常返回地址。中断响应延迟：CPU 可能无法响应中断异常。(二) 在 P7 中，清空流水线产生的空泡指令应保留以下信息：PC 值：用于异常返回地址计算。指令类型标记：标记是否为有效指令或异常指令。流水线状态标记：如是否处于延迟槽。\n6、为什么 jalr 指令为什么不能写成 jalr $31, $31？jalr指令的功能是跳转到对应寄存器中的地址，同时把PC+4（有延迟槽则PC+8）的值写入对应寄存器中。如果后面两个寄存器都是相同的，则先跳转再写入还是先写入再跳转就会产生两种不一样的结果。因此为了避免这种未知情况的发生，不能这样写。","categories":["计算机","co"],"tags":["北航","大二","co"]},{"title":"北航co计算机组成理论复习","url":"/2026/02/13/co%E7%90%86%E8%AE%BA%E5%A4%8D%E4%B9%A0/","content":"写在前面：这个是本人复习机组的笔记的简略版本（为什么不是完全版呢，因为人懒得写成markdown了）建议结合老师上课PPT复习然后多做一点往年题\n\n\n\n计算机组成原理理论复习第一讲 计算机组成概述一、计算机中数的表示1. 无符号数\n定义：数的编码中所有位均为数值位，没有符号位。\n范围：只能表示  的整数。\n示例：16位无符号数的表示范围： ()。\n用途：一般在全部是正数运算且不出现负值结果的场合下（例如地址运算）使用。\n\n2. 有符号数\n实例：, , , \n机器数表示：\n数的正负问题：设符号位。\n“0”表示“正”，“1”表示“负”，固定为编码的最高位。\n\n\n真值与机器数：机器数是真值在计算机中的编码。\n小数点问题：\n定点小数：小数点固定在符号位之后（绝对值小于1）。\n定点整数：小数点固定在数值最后（没有小数部分）。\n\n\n\n\n浮点数：带有整数和小数部分的数（按2为基的科学计数法表示）。\n\n3. 机器数表示及其范围 (原码、反码、补码、移码)\n原码 原：\n\n正数：                                     （）\n\n负数：                       （）\n\n\n\n反码 反：\n\n正数：                                     （）\n负数：            （）\n\n\n补码 补：\n\n正数：                                      （）\n负数： (模运算概念)      （）\n注意：补码可以多表示一个负数（例如8位补码范围 ）。\n\n\n移码 移：\n\n (通常用于浮点数阶码)  （）\n\n\n\n4. 浮点数的表示\n一般表示法：\n阶码 J：采用定点整数表示。\n尾数 S：采用定点小数表示。\n格式：[阶符] [阶码数值] [数符] [尾数数值]\n\n\nIEEE 754 标准：\n单精度 (32位)：符号(S) 1位 + 阶码(E) 8位 + 尾数(M) 23位。\n双精度 (64位)：符号(S) 1位 + 阶码(E) 11位 + 尾数(M) 52位。\n阶码 E：用移码表示。\n单精度偏移量为  (7FH)。\n8位阶码移量 3FFH (即1023)。\n\n\n尾数 M：必须规格化，小数点左侧一定为1，且这个1作为隐含位被省略。\n规格化形式：。\n\n\n特殊值表示：\n：表示 0。\n：非规格化数（尾数隐含位为0）。\n：无穷大 ()。\n：NaN (Not a Number)。\n\n\n\n\n\n\n第二讲 组合逻辑设计一、逻辑代数\n运算优先法则：括号 ()  非  与  异或  或。\n\n基本公理：0/1律、互补律等。\n\n互补律：,  (用于化简时消去因子或配项)。\n重叠律：,  (用于化简添加某一项)。\n反演律 (摩根定律 De Morgan’s Laws)：\n (积之反等于反之和)\n (和之反等于反之积)\n\n\n还原律：。\n\n\n基本定律：\n\n自等律、0-1律、交换律、结合律。\n分配律：; 。\n\n\n三大定理：\n\n代入定理：任何一个包含变量的逻辑等式中，用另一个函数代入式中所有该变量位置，等式仍成立。\n反演定理：求反函数 。规则： 变 ，  变 ，  变 ，  变 ，原变量变反变量，反变量变原变量。\n注意：保持原运算优先顺序（不属于单个变量上的非号不变）。\n\n\n对偶定理：求对偶式 。规则： 变 ，  变 ，  变 ，  变 。\n用途：若某公式成立，其对偶公式仍成立。\n\n\n\n\n逻辑函数的表达式：\n\n最小项表达式：全部由最小项构成的与或式 (Sum of Products)。\n最小项推导法：从真值表推出逻辑函数表达式的一种方法。把输出为1的输出组合写成乘积项的形式，其中取值为1的输入用原变量表示，取值为0的输入用反变量表示，然后把这些乘积项加起来。\n\n最大项表达式：全部由最大项构成的或与式 (Product of Sums)。\n\n\n\n逻辑函数的化简：\n最简与或表达式：\n\n乘积项的个数最少\n在满足1的条件下，乘积项中的变量最少\n\n\n代数法：并项法、吸收法 ()、配项法 ()。\n\n合并乘积项法：利用互补律消去1个变量，如F=A(BC+BCˉ)+ABCˉ+ABˉCˉ=AF=A(BC+BCˉ)+ABCˉ+ABˉCˉ=A\n吸收项法：利用吸收律和包含律减少“与”项A+AB=AA+AB=A。 \n配项法：利用互补律，配在乘积上 A+Aˉ=1A+Aˉ=1。\n\n\n卡诺图法：利用卡诺圈化简，最简形式通常是积之和。\n\n\n\n\n二、基本组合逻辑部件设计1. 加法运算单元\n半加器 (Half Adder)：对两个1位二进制数求和，不考虑低位进位。\n\n\n\n\n全加器 (Full Adder)：对两个1位二进制数求和，考虑低位进位 。\n\n\n\n\n多位加法器：\n串行进位 (Ripple Carry)：进位逐级传递，延迟高。 依赖 。\n并行进位/超前进位 (Lookahead Carry)：各级进位直接由输入决定，速度快但电路复杂。\n\n\n溢出判断：\n若符号位相同的两数相加，结果符号与加数相反，则溢出。\n若符号位不同的两数相减，结果符号与减数相同，则溢出。\n双符号位法：”00”正，”11”负，”01”或”10”表示溢出。\n进位判断法：最高位进位和次高位进位不一致则溢出 ()。\n\n\n\n2. 乘法运算单元\n阵列乘法器：由若干全加器构成，完全由硬件直接计算。\n符号位扩展：最高位是0补0，是1补1。\n\n3. 数值比较器\n比较两个二进制数 A 和 B 的大小。\n1位比较器：, , 。\n多位比较器 (7485)：\n从高位开始比较，若高位不等则直接定大小；若相等则看低位。\n级联输入端：用于扩展位数。\n\n\n\n4. 编码器和译码器\n编码器：\n个输入  个输出。\n优先编码器 (74LS148/74LS147)：允许同时有多个输入有效，只对优先级最高的进行编码。\n解决输入混乱问题。\n\n\n\n\n译码器：\n个输入  个输出。\n二进制译码器 (74138 3-8译码器)：\n输出通常低电平有效。\n重要应用：做函数发生器（利用最小项之和）。\n\n\n显示译码器：7段数码管驱动 (BCD to 7-segment)。\n\n\n\n5. 多路选择器 (MUX)\n功能：从多路输入中选一路输出。\n\n应用：\n\n数据选择。\n\n函数发生器：\n\n选1 MUX可以实现 个变量的函数（如果不加非门辅助）或 个变量（利用输入端接变量/反变量）。image-20260213202936663\n例题：\nimage-20260213203017723\n\n例如：8选1 MUX (74151) 可实现3变量或4变量函数。\n\n\n\n扩展：利用使能端/高位地址将小MUX扩展为大MUX (如2片8选1拼成16选1)。\n\n\n\n\n6. 竞争冒险\n竞争：信号经不同路径到达输出端的时间不同（有先有后）。\n冒险：因竞争导致输出产生毛刺（干扰脉冲）。\n判别：\n代数法：化简后出现  (“0”冒险) 或  (“1”冒险)。\n卡诺图法：相切的卡诺圈处可能存在冒险。\n\n\n消除：增加冗余项、加选通脉冲、滤波电容。\n\n\n第三讲 时序逻辑设计一、锁存器和触发器\n基本RS锁存器：由与非门或或非门构成。\n 置1。\n 置0。\n 保持。\n 不定状态 (禁止)。\n特性方程： (约束 )。\n\n\n钟控D锁存器：\nCP=1时，Q跟随D变化（透明）。\nCP=0时，保持。\n\n\nD触发器 (Flip-Flop)：\n边沿触发（如上升沿）。\n只在时钟沿到来瞬间读取D的值。\n\n\nJK触发器：\n 置1。\n 置0。\n 保持。\n 翻转。\n特性方程：。\n\n\n\n二、有限状态机 (FSM)\n定义：表示有限个状态以及状态间转移和动作的模型。\n分类：\nMoore型：输出仅与当前状态有关。\n输出在状态内部或随状态改变。\n\n\nMealy型：输出与当前状态及输入信号都有关。\n输出标在状态转移线上。\n\n\n\n\n设计步骤：\n确定输入、输出、状态数。\n画状态转换图 (State Diagram)。\n列状态表 (State Table)。\n状态编码。\n写出次态逻辑和输出逻辑表达式。\n画电路图或写Verilog。\n\n\n\n三、时序逻辑电路设计分析\n寄存器：由一组触发器组成，用于存储二进制代码。\n数据寄存器：并行入并行出。\n移位寄存器：支持左移、右移、串行/并行转换。\n\n\n计数器：\n同步计数器：所有触发器共用一个时钟CP，速度快。\n异步计数器：时钟逐级传递（低位输出作为高位时钟），有累积延迟。\n任意进制计数器：\n复位法 (Reset)：计数到M时产生复位信号（瞬间归零）。\n置数法 (Load)：计数到M时置入初值。\n\n\n\n\n时序分析：\n建立时间 ()：时钟沿前数据必须稳定的时间。\n保持时间 ()：时钟沿后数据必须保持稳定的时间。\nClock-to-Q ()：时钟沿到输出变化的时间。\n关键路径约束：。\n保持时间约束：。\n\n\n\n\n第四讲 主存储器一、存储系统概述\n性能指标：\n访问时间 ()：从发读请求到数据有效的时间。\n存储周期 ()：连续两次访问存储器的最小时间间隔 ()。\n带宽：单位时间传输的数据位数。\n\n\n分类：SRAM, DRAM, ROM。\n\n二、存储单元电路\nSRAM (静态RAM)：\n双稳态触发器结构。\n速度快，不需要刷新，集成度低，功耗大，贵。用作Cache。\n\n\nDRAM (动态RAM)：\n电容存储电荷。\n需刷新，集成度高，功耗低，便宜。用作主存。\n地址复用（行/列地址分时送入）。\n\n\n\n三、存储器芯片结构与扩展\n结构：地址线、数据线、控制线 (CS, WE, OE)。\n\n存储器容量描述\n\n公式：单元数  每个单元的位数 ()。\n示例： 位存储器\n单元数： ()\n地址线： 根\n数据线： 根\n\n\n\n\n扩展：\n\n位扩展：增加字长（如 ）。\n\n连接：地址线并联，CS片选并联，数据线分高低位。\n\n\n字扩展：增加容量（如 ）。\n\n连接：数据线并联，地址线低位并联，高位地址用于译码产生片选CS。\n\n\n混合扩展：\n\n\n\n确定每个芯片的地址位数、数据位数。\n确定整个存储空间所需的地址总线和数据总线的数量。\n计算所需芯片的数量，确定每个芯片在整个存储空间中的地址空间范围、位空间范围。\n所有芯片的地址全部连接到地址总线对应的地址线上。\n同一字空间的存储芯片CS信号连在一起。\n同一位空间的数据线连在一起，并连接到对应的数据总线上。\n根据每个芯片的地址空间范围，设计芯片所需的片选信号逻辑，CS逻辑电路的输入一定是地址总线中没有连接到芯片的地址管脚上的那部分地址线（高位地址）。\n统一读写控制。\n\n\n\n四、DRAM的刷新\n原因：电容漏电。\n\n刷新操作：按行进行，读出即刷新。\n\n方式：\n\n集中式：在周期内集中一段时间全部刷新。存在死区时间。\n\n分散式：每个读写周期包含一次刷新。无死区，但周期变长，速度慢。\n\n分布式 (异步)：将刷新分散在每一行的时间间隔内（行数）。效率高，最常用。\n分布式刷新间隔 = 刷新周期\n\n\n\n\n\n第五讲 指令系统与MIPS汇编一、指令格式\n操作数存储方式：\n大端 (Big-endian)：高位字节存低地址。\n小端 (Little-endian)：低位字节存低地址（x86, MIPS常用）。\n\n\n寻址方式：（只列举MIPS中的）\n立即寻址：操作数在指令中。\n寄存器寻址：操作数在寄存器中。\n基址寻址 (Base)： (用于Load/Store)。\nPC相对寻址： (用于分支BEQ)。\n伪直接寻址：用于跳转J指令。\n\n\n\n二、MIPS指令系统\n寄存器：32个通用寄存器。\n\n$0 ($zero)：恒为0。\n\n$v0-$v1：返回值。\n\n$a0-$a3：参数。\n\n$t0-$t9：临时变量。\n\n$s0-$s7：保存变量。\n\n$gp, $sp, $fp, $ra：指针和返回地址。\nimage-20260213203854634\n\n\n\n指令格式 (32位)：\n\nR-Type：op(6) rs(5) rt(5) rd(5) shamt(5) func(6)\n例：add $t0, $s1, $s2\n\n\nI-Type：op(6) rs(5) rt(5) immediate(16)\n例：lw $t0, 32($s3), addi $s1, $s2, 100\n\n\nJ-Type：op(6) address(26)\n例：j 1000\n\n\n\n\n常用指令：\n详见指令集\n\n          \n            \n              \n              \n                MIPS-C指令集\n                北航官方指令集）\n              \n            \n          \n\n\nlb/lh/lw：加载字节/半字/字。\nsb/sh/sw：存储。\nadd/sub (带溢出检查), addu/subu (无溢出检查)。\nsll/srl：逻辑移位。\nbeq/bne：相等/不等跳转。\nslt：小于置1。\njal：跳转并链接 (保存PC+4到$ra)。\njr $ra：返回。\n\n\n\n\n第六讲 MIPS处理器设计一、性能分析\nCPU执行时间 = 指令数 × CPI × 时钟周期。\nCPI (Cycles Per Instruction)：每条指令的平均时钟周期数。\nMIPS：每秒百万条指令。\n\n二、处理器实现方式\n单周期CPU：所有指令在一个时钟周期内完成。\nCPI = 1。\n时钟周期由最慢的指令（通常是LW）决定，效率低。\n\n\n多周期CPU：指令分为多个阶段执行。\n流水线CPU：并行执行多条指令的不同阶段。\n\n三、流水线 (Pipeline)\n五级流水线：\n\nIF (Instruction Fetch)：取指。\nID (Instruction Decode)：译码/读寄存器。\nEX (Execute)：执行/地址计算。\nMEM (Memory)：访存。\nWB (Write Back)：写回寄存器。\n\n\n加速比：理想情况下为流水线级数。\n\n冒险 (Hazards)：\n\n结构冒险：硬件资源冲突（如同时读写内存）。\n\n解决：哈佛结构（指令和数据存储器分开）。\n\n\n数据冒险：\n\n写读相关 RAW (Read After Write)：假设指令  是在指令  后面执行的指令，RAW 表示指令  将数据写入寄存器后，指令  才能从这个寄存器读取数据。如果指令  在指令  写入寄存器前尝试读出该寄存器的内容，将得到错误的数据。\n解决：转发/旁路 (Forwarding)、流水线停顿 (Stall/Bubble)。\nLoad-Use冒险：必须停顿一个周期。\n\n读写相关 WAR (Write After Read)：假设指令  是在指令  后面执行的指令，WAR 表示指令  读出数据后，指令  才能写这个寄存器。如果指令  在指令  读出数据前就写该寄存器，将使得指令  读出的数据不正确。（如在流水线译码阶段读寄存器、回写阶段写寄存器，则不存在 WAR 相关情形的冲突）\n\n写写相关 WAW (Write After Write)：假设指令  是在指令  后面执行的指令，WAW 表示指令  将数据写入寄存器后，指令  才能将数据写入这个寄存器。如果指令  在指令  之前写该寄存器，将使得该寄存器的值不是最新值。（如只有在流水线回写阶段才会写寄存器，则不存在 WAW 相关情形的冲突）\n\n\n\n控制冒险：分支/跳转指令改变PC值。\n\n解决：分支预测、延迟槽。\n\n\n\n可以用时空图分析：\nimage-20260213205305324\n\n\n第七讲 高速缓冲存储器 (Cache)一、Cache原理\n利用局部性原理（时间局部性、空间局部性）。\nSRAM构成，位于CPU和主存之间，速度快、容量小。\n结构：由 Block (Line) 组成，包含 Tag、Data、Valid位、Dirty位。\n\n二、映射机制\n直接映射 (Direct Mapped)：\n\n主存块只能映射到Cache的一个固定位置。\n (C为Cache块数)。\n地址：Tag + Index + Offset。\n优点简单，缺点冲突率高。\n\n\n全相联映射 (Full Associative)：\n\n主存块可放Cache任意位置。\n地址：Tag + Offset。\n缺点：比较电路复杂，只适合小容量Cache。\n\n\n组相联映射 (Set Associative)：\n\n主存块映射到固定的“组”，组内任意放。\n\n。\n\n路组相联：每组有块。\n\n主存的地址格式：\n\n\n\n\n\n组内块地址 (Tag)\n组地址 (Set #)\n块内地址 (Offset)\n\n\n\n\nTag 的内容： 主存中与该 Cache 数据块对应的数据块的组内块地址。\n\n\n\n\n举例1\n已知条件：\n\n主存容量：1M 字节 ( Bytes)\nCache 容量：16K 字节 ( Bytes)\nBlock 大小：256 字节 ( Bytes)\n映射方式：4路组相联 (每组包含 4 个 Block，即  块/组)\n\n\n待求解：\n\nCache 分多少组？每组包含多少块？\n主存分多少组？每组包含多少块？\nCache 的 Tag 需要多少位？存放什么内容？\n\n\n\n\n\n 答案点击展开解：\n\nCache 组数计算：组数总容量大小路数组每组包含 4 块（已知条件）。\n\n主存每组块数计算：主存每组块数主存总容量大小组数块组\n\n地址位数分配：\n\n主存总地址：  位。\n块内地址 (Offset)：  位。\n组地址 (Set #)：  位。\n组内块地址 (Tag)：  位。\n\n\n结论：\n\n主存地址共 20 位，其中：高 8 位为组内块地址 (Tag)，中间 4 位为组地址 (Set #)，低 8 位为块内地址 (Offset)。\n\nCache 的 Tag 应该为 8 位。存放 Cache 块对应主存块的组内块地址。\n\n\n\n\n\n\n\n\n举例2：\n假设有一个 4 路组相联 Cache，数据存储空间大小 64KB，块大小为 16 字节，主存地址 32 位。主存一个字含 4 个字节，每个数据块对应 1 位有效位。此外，Cache 采用写回策略，Cache 每个字用 1 位脏位 来表示是否被修改。\n问题： 计算实现该 Cache 所需的总存储容量？\n\n\n\n 答案点击展开解：\n\nCache 每数据块大小 (Block Size)：\n\n  块内地址 (Offset) 为 4 位\n\n\nCache 总块数 (Total Blocks)：\n块\n\n\nCache 组数 (Number of Sets)：\n由于是 4 路组相联：组  组地址 (Index) 为 10 位\n\n\nTag 位数计算：\n位数主存地址位数组地址位数块内地址位数\n位数\n\n\n控制位计算 (每块)：\n有效位 (Valid bit)： 位\n脏位 (Dirty bits)： 题目说明每个“字”用1位脏位，1块含16字节，1字含4字节，则1块包含 个字。\n因此，每个 Block 脏位为 4 位。\n\n\nCache 实际总容量计算：\n总容量块数数据位位有效位脏位\n总容量\n转换单位：\n\n\n\n\n三、Cache策略\n替换策略：\nRAND：随机。\nFIFO：先进先出。\nLRU (Least Recently Used)：最近最少使用（性能最好，实现较复杂）。\n\n\n写策略：\n写穿透 (Write Through)：同时写Cache和主存。配合Write Buffer使用。\n写回 (Write Back)：只写Cache，置Dirty位，被替换时才写回主存。\n\n\n\n四、性能分析\nAMAT（平均存储访问时间）：(: Cache周期, : 主存周期, : 命中率)\n加速比 SP：\n\n\n第八讲 虚拟存储系统一、概述\n解决主存容量限制，提供比物理内存大的虚拟地址空间。\n利用磁盘作为辅助存储。\n\n二、页式虚拟存储器\n页 (Page)：虚拟空间和物理空间切分为固定大小的块（如4KB）。\n页表 (Page Table)：记录 虚页号 (VPN)  实页号 (PPN) 的映射，以及有效位。保存在主存中。\n地址转换：\n虚拟地址 = 虚页号 + 页内偏移。\n物理地址 = 实页号 + 页内偏移。\n页内偏移量不变。\n\n\n\n三、TLB (快表)\nTranslation Lookaside Buffer。\n作用：作为页表的Cache，加速地址转换。\n全相联查询。\n流程：CPU给虚地址  查TLB  命中则得物理地址；未命中则查页表  缺页则从磁盘调入。\n\n四、磁盘存储器\n结构：盘片、磁道、扇区。\n存取时间 = 寻道时间 + 旋转延迟（平均为转半圈的时间）+ 传输时间。\n容量 = 盘面数  磁道数/面  扇区数/道  字节数/扇区。\n数据传输率 = 扇区字节数  扇区数/道  旋转速度(rps)。\nRAID：磁盘阵列，提高性能和可靠性。\n\nTLB，页表，Cache 三种缺失的可能性\n\n\nTLB\nPage Table\nCache\n是否可能？及原因说明\n\n\n\nhit\nhit\nmiss\n可能。TLB 命中则页表一定命中，但实际上查了 TLB 就不会再查页表。\n\n\nmiss\nhit\nhit\n可能。TLB 缺失但页表可能命中；信息在主存中，就可能在 Cache 中。\n\n\nmiss\nhit\nmiss\n可能。TLB 缺失但页表可能命中；信息在主存中，但可能不在 Cache 中。\n\n\nmiss\nmiss\nmiss\n可能。TLB 缺失且页表也缺失，说明信息不在主存中，则一定也不在 Cache 中。\n\n\nhit\nmiss\nmiss\n不可能。页表缺失说明信息不在主存中，TLB 作为页表的缓存，其中一定没有该页表项。\n\n\nhit\nmiss\nhit\n不可能。同上。\n\n\nmiss\nmiss\nhit\n不可能。页表缺失说明信息不在主存中，而 Cache 缓存的是主存数据，主存没有则 Cache 一定没有。\n\n\n\n第九讲 总线与I/O一、总线 (Bus)\n分类：片内总线、系统总线、通信总线。\n组成：数据线、地址线、控制线。\n仲裁方式：\n集中式：链式查询（线少，故障敏感）、计数器查询、独立请求（响应快，线多）。\n分布式。\n\n\n定时方式：\n同步：统一时钟控制，速度快，适合短距离、速度一致设备。\n异步：应答方式（握手），适合速度差异大设备。\n\n\n\n二、I/O接口与控制方式\nI/O接口：CPU与外设的桥梁，进行速度匹配、数据缓冲、信号转换。\nI/O控制方式：\n程序查询方式：CPU不断轮询状态，效率极低。\n中断方式：\n外设主动请求，CPU暂停当前任务去处理。\n适用于中低速、随机发生的事件。\n流程：中断请求  响应  保护现场  服务  恢复现场  返回。\n\n\nDMA (直接存储器访问)：\nDMA控制器接管总线。\n数据直接在I/O和主存间传输，不经过CPU。\n适用于高速、批量数据传输（如磁盘）。\nCPU仅在开始和结束时参与。\n\n\n通道方式：独立的I/O处理器，执行通道指令。\n\n\n\n三、关键对比\n中断 vs DMA：\n中断靠程序传送（软件），DMA靠硬件传送。\n中断响应在指令结束，DMA响应在总线周期结束。\n中断处理异常和控制，DMA主要用于数据传送。\n\n\n\n缺页：属于异常，需要从磁盘调页。\n（单独强调，因为作者死在这里了）","categories":["计算机","co"],"tags":["北航","大二","co"]},{"title":"关于睡眠！","url":"/2026/02/14/%E5%85%B3%E4%BA%8E%E7%9D%A1%E7%9C%A0%EF%BC%81/","content":"关于睡眠的一点分享（作者尽量使用了通俗易懂的语言！\n\n睡眠分为两种：非快速动眼睡眠和快速动眼睡眠，接下来我将它们分别简称为a睡眠和b睡眠。\n\na睡眠的作用主要是放松身体，促进体力恢复和生长发育；\nb睡眠的作用主要是合成蛋白，活跃大脑，促进学习记忆。\n\n看起来很难理解和判断呢……但如果这么说：a睡眠不会做梦，b睡眠会做梦。应该能够理解了吧？\n\n看到这里如果简单这么认为自己是a&#x2F;b睡眠…也不对哦，因为这两种睡眠都是正常人所必需的。\n\n人类正常一次的睡眠时间为8-10小时，期间a、b睡眠会循环约4次。如果一个正常成年人醒着超过15小时（也就是大约早上8点起床，晚上0点睡觉），则下一次睡眠时间会明显增加以补偿睡眠不足。\n那么，为什么有的人觉多，而有的人觉少呢？ \n因为睡眠和觉醒的控制是脑主动的。神经和激素通过复杂的相互作用，在脑的某些区域调节着觉醒、a和b睡眠的平衡。如果这些脑区产生异常，则可能影响正常睡眠。比如某种嗜睡症是由于促食欲素缺乏导致，而失眠症可能是因为GABA分泌减少…\n要注意的是，引起这些变化的不止有药源或医源性原因，它与环境、心理、性别、年龄、行为都密切相关。\n而睡眠不足又会导致内分泌失调、应激加强、情绪认知调节失常、记忆下降、反应迟缓……还会增大老年痴呆症等疾病的风险。\n可见，保持良好睡眠是一个正反馈的过程。睡觉不仅仅是享受被窝和美梦那么简单，缓解疲劳、促进生长、增强记忆……它是人正常生理活动必不可少的。\n\n当然了，这些只是很简单的医学常识…说这些是让大家能认识到生命活动的一些基本逻辑，明白什么是身体能接受的、什么是可接受但不能长期持续的、什么是不可接受的，以此来学会如何照顾好自己。生命坚强而又脆弱……微小的个体能成为家庭或集体的顶梁柱，也可能因为日常一个毫不起眼的坏习惯而使身体最终溃于蚁穴。\n\n希望大家都能拥有健康的身体与心理！ \n","categories":["医学"],"tags":["医学","奇奇怪怪的芝士"]},{"title":"Hello World","url":"/2026/02/12/hello-world/","content":"\n  1c52c946f7314b1fab579b70f9559fc9bd7977726b2e4ad3bd920b835fe014053a012b9a2b5e7d2a3869c9fda8cc9e9543a62c8fd61ab912105c9071be7c12f05ca57f553fe26f7fbb0a84fcf9cdab751b051bac591121de63c4771b182946bb0ec480be07f39df5fa525db344e3f0b791916fee96cd82b4ac54b5bedecc676e2eb7d8c124a2f1c08ae53cad9924f8a20f9421683bce6ef62ab1be34fd0431112af4c8491319bcacec159fe9eacf672efac8824792f59820ce01705e9024249b7b1504abc63360ec35c628567f3a9d07e22c7e7abf6b083835a7dc1bb79977d40cdfd6aa10a68ca028ef03302700ce162d226c139f024574d221c528a4cc7d96bf0631bb748f29e003b4ac10095c7fb9a75a74f58201fd3c8c0c64df37c04b0cf9b96059ba1bc01f02a088d4418c2b835ec830bf57db9f00b307e69a9ade604abaf94bc4247497f85cd307fd25caf13a7ad91d3a314a9bbe549efde08f07c24cef788c1d6b9493a0892f0f4d172c13004f8015e0b6c6bf6ef427ac428e44cc81c4476aaaeb98d060ab475f9fd8b084802ccbff1c5952ba90f0b87d0cdb577abdf96a116d503935da1511fdac1f20eb76197e94c487e4570c24b46600c1afecb5d7c87262d6cc75a25a47104f6522cf14edb51d6f602c4f875c5899f8326bc74826e18e37c2328a436875ae167bb4572b2068d797bedd755e6895d1be850230007f380ad8f8a6530f7eb12ab36e4998b3b76f20a0048e2818344e39582a5557e4c1b8c280482bb6a6a6bd977b5cb2e0ccd07e0193ee97f5178b5102572f73a479788cc9d8d35345aa1d319ea4741c700f3be41137b3f3ef9e8c4432d2dbc1e5b015d0033f38869b2b09c9f9c4cc2740a50a2a4ef923616978bcb4579b60041b323e22837f70467139944f85e1e4a04dff775451bdf0f3aa8dd622d1d4e335271808276147890d6e3d6726cd28f5315a7574aa59554052e947f3eaf50e97b42df86683194d4fd090ee5e403a6328d008bf1a851077aefbb2dbe439afa8c5e90059039dd2f5fc2c791b21ae6783bcb6bc24727d2155a178bb4b61a174906318c09c96d1d07cff444805ec16710cf9560fc49291a568a6d087c85842b0362f9d7e7ba972391b44193c844c8e31dc75a7cafe8328805c2fe2069a17860e5000e37cf4c6a84647d38391e5fd6c439f38653b306850f03d2b6223b943aff9812d74f6fb3ec252767808a755052fec0011d0ca6a7d90fbbaf94b761c96f489c25a5ecb439adcda30c32959fc9cd1a1a8cc424bdd9172f121b1e78be2405f39c5d5b32b151bf31263436c556464d2ba9e27491801a698a1711c1cb71897a6a6d0882b7a4aca6121de1867619691f4760dd0809942b38c4556698d3de8e4c239ff467a164861916a35a19a10e6b05432d2e4483e69316af8997f7bee66002986b482430a9f3d188ee1177b5a4d7d5a7cb4f1524700c46fac2d2bf30a68ab28735a4522096d561ccf96fd785b996eebcf0e664ee462c3c073effdb9ef12b154f83245be8e2fc99c244f427ece08529b4a2664866bad0544fac4bd4a2d791b40a68b93567cea80d5e087b5efd5b490439a4ebcf44f9af684801df7eb3dc176ae781835477bc16c333e3f49830f82329e7b99b2b9b37752bcd402958605f4357d93971911469b0cf66f08a04c1f312a2dbb3886239017f2c81147956f69d2aead0c2091b91213ba8e2f9ae73f2501bd7ba4ade1f56254b8f3446ed154396c0c4664f2883d548cc5daa91159faf4a1c2a042e41fd66a9770d43b6955f31e8333e574d96e7cb461ad915287b63d9f284011af5c8b48e01af0e751467144936ac432ee3121e3d5981d78f48af1843c28ba8bd89afa0d863cc72f0aa2ddc973529ff76db9fa549e619507f5f4fd6797b1013023de57ce04483318c58d1f2a131304631d0503be7dd81ee2b26ae438b08d7ce37f33b3bf1970b7d43a5d2f536b938376a4e0092d2cb6694e21d3179fe433c029f8738f5213f91703cf5388a100968a9027b172a4dfd04a93a64ab9e5cf653eab4ad69fe5360f85344b80952792b477721c1a73cc611df6e8182d564809b229e21ec7db624d6482d0b22020ee3186f1d2d78fe3bb065aec023883997568fb5eade44e69f6d23c13555f965ef616c82ca16fdfaabd4ef91a150e091884b296a28f422b8465274315a7c132742f2b331c71b37066f3d11bd38b3ccddf1578417199cbe419276d4f570dd0186ad29a95b3dcbecd972819ee2a4e612580268d1c84c62c1ec462949d0dcc29838dcb74079a087ca725e17e8213e1fd05be10a34160f874068f46b4a1470c8a759f66c8ea0d772e921e15cb3243f5d22cbaca9e4b34e5b208355da79d9971588d744ac112f5a5a492d19e458893cb00e628aa30006a3265d23e77e3da444b0d966cc33250cd3c3ae6f7219c6a73f515d690c7c36d4730d7c501ff00c6e54b2f85ad1eb0ee4fcdebbfced9ba55731ca362af5386032defaf7daf1790d6ba5efc6b85533726c028c3135c292b5756da43ca998eb9f7ac2c6c8e48d4acc7682d6eec50c5b9f46bb59f6afeb53feccc0a986881d9248b930a2ee9cad3eb1642d734ac14bb4f8ee456bc0a2e2aea4942da221bd0d3ef020d56b4b02a357ad2c43b2e124382e6603d9d68082e33d05a4ead940022d6c7846bf6eb8a3f6352587e6331bad1d93559420db2352f87f006e1b99ae3b227e24673dc8c07161d75bec30b2cdcc0f0904f13e892ca3196996c315975d80dbf80f009e04f4c5e8f727fba8cf55b81343db98c0cc3999d5e2270e5c693e6d40e99fc96c1fd715b1f74918f2ebea56629f856c86cb70c3e34278bf9d5e2543865bfbd281210ca7ddab6b729e6adf37514f4314606963b06b3f6f176a418f740ba2f0123fc055bcbac271b41603e476f8a2c9908253f630c89b4cee0185c49913094c5b5a2306bb3806798c9d49ee4b6ec2b0171a1423ff4447f9aaf0f75f20565081c89ccf2d85405566a15f5dacce6b6cad26dd0781c32d82f60ec62df5156f659ef31a808b146d3e24bff65ac137f93834dffb9041f36471f6356dc78799b0ffcbfe16da7bf30b9c108ed936d3bc6f0656372b3ad93180871786c651e30c49b24cada3acfe922c510145f69f69a36579e356580bf4e338e2d491c6ddf75698a67c38a12c124b50de4236c0421e390d4e6b06eb85992c02614f61b82e90bc54da9efdc3bd2f57e236764eac5b3bc004c8b977541d716048d9c97fabe85e4d1cda79ec548fd2ae29ebf937a9c79d7913dcdafd422c010682abeb8bb0c8b6540d603f21fc662f9ad3cd6ac4d02fc9a154e06e6ffb2cb5e85cc4f72bcc28c956efdeb3565b366c700bf017bd069961a08b8dc2fdc8fa215b503cb417bf224cd1d94b18c8a4eaca33ade7f1f4a551dd61889658fe9a24163d2daee7083c9b35516220513b53e993565df7bf00b81fe8a7875d53968ede8e0dcd28c771e16f663927b2cc039c0f1311ae5d9827796202d8300a8860d05c01006b25a9863c99848689d2e1d05bf6a8419e5a794dc1b466d64706d3a04a4e8ab326ea178390fc0c90398a5bde0b94e0c68b18ae4bd78e3f2f3c1531ad524659fe1d67188a54fcea6e0e00211a7798cd6a1f7a63396bb5f30ab3441b024e0fd0a18efca7db8c025b1d93f55cefbd54dd93b35cabcba3c87a41086b3a794b127ce263585f1a1698b0b58e333b43b6eb0751007e2f1f92726c7d11dc1e7432f336695d9c83f3eccf3264dbf06ae986021c4fad2921f6a00c0486fb166c0f7f059b78d29c6a2df122a912e1a48a090857cacac6ab1a8ca4c6219c3022adaecdbfc84c09a02015ff63f62cc1d74b1fbb6268053eadc5aa2dd34d543884b605f202ea247d287c4063c98c9e466ee0837946e9ea1262294f3f4900c503635c574590eb2818509694346a0eaeeebbeac2e1e5470bb0c4c28c34094ebe063aa994899b5452c3fadfb29fd4eca431127edd876da7a3275c2f0220607d93736e15806c72cbd989d2b4deaebeee29c82e942a56ae1bedb56f9861e1a9fe4eb6ec097b5572abccc9c4d309e274d2cab4e22e9a10447dfd63ddcc8f1d0853d5337ad07b0d3cb2803d1223e9bd488b884b9c0973fbae15d195c52220e708ff214a2c6da5f5791e40348250dfb877770edf35528c9697693163d6e1982dab95dd5e8578874eaab15705510254768ddc2cb9a5da0470c7ff12fa02dbdd2fca3175f7243dc0c8069b102a0e47567ab7d9fad6b6f5199988fd740cbf439128955632c427936008d186af9d44f2d6aeef03bbf1f49d4f972b1a37d330170630a569829c04c4cac1cee75b4d6ff3fa9295d6c92fc730cd7ad690f1be7f433d2d5bf3c69e193efe415fb900a7481b596e8528ba72a1bd665472d1395e60eae28722a9edcb7d0c83d9ee6f16e75e536ed16259b362f8ed0614cb674fdaedad5299823c3a9c1e5532e55c1da8d9c02c00c83a16d996667095d78c8471a2a497d9dce4a6069ca86856eb72d43600db61d1524ae5e280196088c93351bc3fd537f8bc0f4e917f8601811bc923cfb07e932f22c1589ff3676951b331ef7cb234992b8e525a9976641cf395c128e4d7743c1bcf997d73e27a3c9df07196deacda07f766375e14e7e54477f1e27ceef375d27f289aa1333d87788c9ec2386b7ff8882a52541844d762d08cc01ff4c61fccfa61f7424b3d45ca65fb262838e4ddc0db06c57ff3d2ced1c477d77efa1e2630789f0d03a4b4551f7eb55a86e68c6d6e5ec00e733dc9d59e96c36239a959ba8c21c02c81f758d8f5835eaf03836c6e0f17d694c097b9fd94b87f61713986464f877733e41b55b120b873f6d1b74b8290d21dbceebee2c907b62053064beb492ddf50ed82e7cff97214762deac2d566a78beb557e65ea5ef575d78d8530f5f9c08f7f1a9769446cf451666f7467bb6aeda823f85f0f1eb2495a218246f5a3f873f106868c4b22e0d755e9012c4d6a8b3350632d8241a0138d459d6f493015ffdce7e4c0df435b419dbf0a912840ff4dd50854f19829198368d37a177b716a330da996013208655b4007dd8849a6d483eb8637aacf53834dd53ead6569f349b0dadec7d34ed8abb2d2ca264c8a1a0c7e681353951d946b7754ffa0e94bdc8920322eca741c340deb75f12dbc79374c37c5d400893dcd804cc3b86875634d19348effdee9e5138167cee5b8cb42e9591648137985205e22c218aed31332ad6cf0c2a285a5f510531bb0d3bfd4264018c2fe671244c5dec671f3196d3a9a968ba2a5701aa4b2dd7e9e5d68858bea3dae5dc93cb32ca3c96394916cf9ae962ed60134bf650762557b227ee625d293ab2d3918acc6479ac6c86306cfad4e271ff763b95994c78c69faa7244028c0836f4c4bb5e7682a0294e35d5a2fc83a20f8b7b8d7d53b35fb1b61b242b4cc6752d7312f5a1c6f8d6237c8b9c495ce8d331b3b91c84fc04dc2f5a620dc2106ab3955ebde3730ff7995e87ad0450bd59271a57b63fdd92c5efe42d1796c81fa428e3e45579625e5a916524ac9cd4b3f7ecaf39a3f17f39092aba79bd493efb93683dff809bd8e4c48b90971118893fb4a0de9ef9c31272be1a6be377614184aa2c8fecacf91700f883b07e3bf98e6e1b92c4f9d521e2d8963c73c549da04175694a0af64ea7b65afe41bb60b6974a8cc532c324d4a1d5518fe7538144506003251a88a6e3078bc6d079e85c7e696cfe07ee12e89ba3219e810cb396c68dfca3e4d900ea624ea9b581a8f424d14975d20b0dcdb4a2f5cd24f05fa275622468c52f707b8e583fe50a6afd5f2984da5351c3f923ce1353afdd27bfe18afd5764b6b26e9f29b083e17246dc0b5fb113532ead0328b87275f91a9f977c6341b4dcffea5b2e1984149d250137a404fe6daa94adb1fa03ee8421dab5bc384da4f1572aba93e7cfbbe8ffee0090b8a3761486cf739e5154c0343fa1d5aba732a7764a0a3dde51a43be049547e0479fdce66f2fd87b2806e51ecd337c96465a9ca07ea8e9b26e2bd9578d278bbbf1fe6dd10a1a0a5bdab7c8ccd3e5f1460305fef4d8a6be98024827d0607b4f1380f610fe8d25c470873ef7f9fa7d5d6308eb9f7a40ba30d35295c7df591f49018961916c86bd1d51021f5f44e7875163d5cf2ec9eacfb50f9414518469cf60d07eb961c193793c1d14eb5ac15f9a95918f2a2c4298b29225f172e8d679288a53340492abf47ae7d733ce696a32158d5530df1874fb9f3a4ea267056a78ca41871a23f762f8e460d4421fc27eb2a5c02b7a76911f79bad35cd6fd035dea917522b6f72d0f35d63a17767047f412d8fb84c9a87f3e823dbc02e73c5f94f39e3fea7f0a6ed69c117b5d089a62fcd2fc4f8a05c760f935e83ebf39a0141dbce256855fd08264924d4f3bc1c12e7d4623aff70dce9e362b31628a3e319cc110f32c5e2044423706fa1fdc0fdfca5cf6b017d034e079c3944670ca8d6b29530be6ea14334c82b01e669e1f7d4634c109e0da299e95a1b1158cccaf27fdbb0180f4f2de0f7c3fcf114a5855013aa8f11570b0a2d53ee07b2a7f6551c59afdd4d8300762b7679161a296b59adcf76fe34195a5c7fb2fc611c3dac66a148a8ac04a1f29fd3e08395046b925df94bc741bdd38a8d6d047e666e97f65524be9cfe586b23d8334305b103e9615cdbc48d6c3a37f33600b99b22bdf659dda6a7eadcc25c842fb0155a56dbb6fd6c7eb2fc9fa660bb7c1fe2845e6fcecb91681a3404d8811a5ac112585e9bf5d7559715f257a022754edd3dfd791e635862a67c7093e13b6f0b42dcd84b0c67e7c8defd344c3f3084207298ae08c5c30f8b02b9bfeb9d658b35966eea41dc9591bafb3720408671e55ff58b895fafa749c3791ae1a17be4a317bbcde9981a9726c53eba204e858d01c9b30204c6f5bb2eed0ea8e4568190fa4ee91caa482c87f265cf9fadcb1e088ffc194c31469b59a86dddd823401ad1db40ddd20f815cfc9c647dcee6c50e507e050ef515aa076559bb006915f96b1b99f0e07bac179f6f3f40486cf9cac64a535657e182decaca8b0bfbf1e10707bc697dbae5fe5b194d49bdc9d87be9dc26234bb1f9ecc34051ead067c6caa2c352ebfd3ff937a7ff666c47645e324d5105269c8d5918717d5ff64e627540a09932e79cbc2dd3245b92af993345d7420cb87df7b822ac2ce826ae89164b6e66a7d41bd6b9f152572a635ea76fdb2a860f8bc4c41fbb0b5c38d606c4662f0a4a9b6829871449966cf8fa38033de0ff50ac78d86f746d414f8b00ba625220a38d148387d49be721982a09fb81a39bae6c513bba45dc3ea34fd2fa71168473f1fc80600a34c0f5f0dcae4c300eb6b950f24a51b243a295c93d4e088e1f5ac3417e34e639218c85133beef06b11f45ca5c25680769d415b9671f60be612a1cb96878a3d19050ad463907194acaea4ba4b61f7ab24c911a80615e8dc6be88742c9b43344c783706effd80170d5b1defa58f4fd121e47f9d9cd40384044dfe3ce10b5032d3be1e25ffa95e211082f4d4544e46f487579eee9561a049f95fb807df7578db6b71769f9eb1b61ac42dcbdea4f0eb81a6ce68e87f32c43b3dd9ba4b51934183d036ae91f42d25beecd324b0e7b1ac672608a64e1bf6f2f4b8dd3591bc9b15def73e9a76b8bcaa5c974e5ce89d3ef51cfb5925a9ef49983769781969ff9b5f8850bb3d0340eefebefa1e8e68a78e407a42f4f36be21178239741580d5f1ce70cf32ca41dc3bc5f0074f1ed136efd24da45bbb44a5ed69c53d2416a25bc5e9426b3756c794c168e0ef84c90389a1bf978bc89760f6fbeece42f4cd50cb54efdf60fc90e7ae2861831b62bb2c786adc4e36cf59645d7b22160d5c3f305262d06ff5bf56f9e6776048914e6835ab3650ed058c6066257bd28955750f95a82ca0bd15e1944d726e4b016fb560412d1789e758896eef619ef0b26d891814f2cf0acc53cfc15b756921ede023254e1b01fa3d66ec8afa4a446bd48ef54b6c3207bd7d05ce74e92f9b9d62d6976f6d2341c9bb5d1ac595d21df940ae057390d0edfd382e3dc959b22db18ea8d8aad2d58854d2bef4251823b728f249f20ed0d4a6b9f431e33048172cc6a2ed1ae0e9c7721865bbf30ec48e076cc2603daff670ced3fd5ac2feabb6b2fa8a990ef3e76a8c554336a4bccf9758939b05f7a2460cc1333f827e2ee952b8303e41001652a613cfdf88fc06832dc0d3e21a03acd9dddd1ef869ac892860079b44087278a542a3135cb7610d3e7726f1570f3052fda4d67ec6f3bf7a73633c1020bd436eaaec02fdd1cbf72db6032683fc0bd38854ee411c9fa15f30a06d4ccdb39f09d837b605df30bc32d63ae7601e2b4bc156cb974e5a0d7d2bbd8b331eb5d4bffc17820fd69c8c97ad45068523a49ded0bec68834865774b44d2636e8a93c92dc74e776aec9376913e16e749d3dc4da99e165950a0425ab4440a42ed9301b241f6dbc070260517d5f74a6f17432a71e55d6787ca290278b31f18420a9e9a488e302baa188471f9233cb3673de0f0ccc7c08f22cee38acbe4e5050c92d1f9031d74e9851cd7466d13f9129fbe299c347ecd46b7a7927a4c893ddf8e223886ac74429a4f5089e47dd9ea354e86cf3fa4b4407957d130968814fb111dd6a135226b001b79d09f372eeb83d26053bd21df8ec73e869fdd441eb4ee25a5dbd2227bb8d6a892dd5ee7da46785d64021bf3ebc93202d004e4828ef62930b73b7fee027b1eea268267b9e1be3fc70c7be373fe1f13735c50048804b0cd7a3de1d12594a4075d7b8c26b4db2cf6512e125e9b5c21c84f1ffa84cefc786b258451c3b56be13b045239ec28dd228180803a9c2b346813ea08ec143dc36b40c7d15619ecddd1534578b7f19fa19c7dd7564f4d01c39007b292faa4f4512fa9ed5954d48e5e4608dc2bd2ba568dfb741a5efa1defd4a2145dcedd8089dd60dabcf3c2351f81ffbf894ef6e3d004c8e4ec37f7315f8152305d68d945c640eda30aa58a2e3af05bfe2381b0cb6ec1cca09f25192ef5e4b52d739c22dbcca270bbe62548682ad78dbf2fe681bd733ae244c6f73a03036f2da9391499c3735c3db6c16d64811be5fe8c393b3620a071f0f8d2aabfc4576ea117e9315a2bd6b853a4193807b85312bea1889d0e5d1f12f13db64ec41f349e3ee89deed2cce4b907949f6c59a74ee42db7d444da626854b42ba01fb081c5211356d02a5bb397a5184b9fe63b2ac0348f0e53fe4c8f001316d53d56c79fab28122a661777a6a5f9365a0f98c8f20362d0d91f4968a4adcecc339f4a6ca7582bb348ac4c6593c9dc73f0fa4d5ca1f9b9513ecef2d6ad43b3d2d4e8af7664afd52039987e3f732a48ae5b1e5530f2cbeabfc702912576be4aa9ee74f347fe46efe926477f71c901e6c44afa9d1c5abf9d298028cfe19b67288be258b94d296e6f8264c4e9a496354f2cc0212558f9baa25b03602d4da54d03d7595ca67a86f6682186dba3303b8cecb0e3e8f67d831135e40ecbf9dc1c2a4d91b61c52b3d61db5bc6a731f7e89680107b7949c1c905679e06d090f718be8f8ed5cd7630012cd771da0bd18315f0f10fdaed133a875e5cda39e5d2aefe43a92bc1325b4fce15ec5ed6d0907a605f9c5a7dd9e0414d5e921060f2f820b51b729ae1766dd72f745157ea8e8d755c1a5495c383d163ebe085bf6bdce8f0549436618851b779257352c2d28178c72163997144370fd7e8bf885c4f830273647f4d8fc57db48ce4234a2d1e6f765601ee442d1c02f3ee0867880e29adc2b349c41dc67a8870e3d5b1a04b9765bd27f58b0298b4de2f92469d234f60e7fe2f0d2c5c2b1745d9c58b651ec0fcc58071c4a3861d98f4cf96aa6dfac88b8adb3f49608d52a177760bb5e8c66baf7cfd70e9af567471351cc3096fc1710d7761c6ede610837b99edfc48474fcce336310cc309d658b77788cee0382cee8a17941b5be8790006ca438d133ab86f944a28443b03e2cb21eb705f474474ce0f0e2dc9366cad7e8b6d6935d694b3300e94c788ed1e4eef46ca97e365a0b86779b0ebe482eec242681ca9fa3d9224d34e8cf2869bbbc41136eeee038dc9d781ae91c4fdd908c320d295457c1ba7fdbd945b694274fc2bdc6644ccbc0558569e3fa50108277eb9c8987075e85d76c0dfefce61d9dae71ad79bb62ce915f699bc67e28e6eb1891e4106136ba82f446d2baf7eceaf60fc2b7726dafac384a1e6b592a974cfe49cdc6a25ae510c887455494187c0aeb2b2c4421807f6724aaa256e694108abbc04390f2cf6a6d84ae0f9e834fce7ecd0d7be9a9d379bdeb6b2416b8c2c869ee0ee37b8842ff9c890921bbeabe047a1ba4cab7ec50c9fcc28dc77e16290d787e7be8f1745636774af60a8d328ca5380742ed55bb684ff9df3b7cee06dd1da5b4c376217e1e0bd5d3ac2505d8cbdedcfb09a9cdc43\n  \n    \n      \n      \n        您好, 这里需要密码.\n      \n    \n  \n\n","categories":["个人文件"]}]